<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid</title>
    <style>
        #grid-container {
            display: grid;
            grid-template-columns: repeat(56, 20px); /* 26 columns */
            margin-top: 20px; /* Added margin for better spacing */
        }
        .none {
            width: 20px;
            height: 20px;
            background-color: transparent;

        }
        .square {
            width: 20px;
            height: 20px;
            background-color: lightblue;
            border: 1px solid #000;
        }
        .wall {
            width: 20px;
            height: 20px;
            background-color: black;
            border: 1px solid #000;
        }

        .path {
            width: 20px;
            height: 20px;

            border: 1px solid #000;
            background-color: lightcoral;
        }
        .shelf {
            width: 20px;
            height: 20px;

            border: 1px solid #000;
            background-color: lightgrey;
        }
    </style>
</head>
<body>
<h1>Simple Input Form</h1>
<form id="inputForm">
    <label for="hall1">Hall 1:</label><br>
    <input type="number" id="hall1" required><br><br>

    <label for="hall2">Hall 2 :</label><br>
    <input type="number" id="hall2" ><br><br>
    <label for="end">end: </label><br>
    <input type="text" id="end" ><br><br>
    <button type="submit">Submit</button>
</form>

<div id="grid-container"></div>
<script type='text/javascript' src='AStar.js'></script>
<script type='text/javascript' src='./JavascriptFiles/Hall.js'></script>
<script>
        const Hall1 = new Hall(1)
        const Hall2 = new Hall(2)
        const Hall3 = new Hall(3)
        const Hall4 = new Hall(4)
        const Hall5 = new Hall(5)
        Hall1.addHorizontalHall(Hall2)
        Hall2.addHorizontalHall(Hall1)
        Hall2.addHorizontalHall(Hall3)
        Hall3.addHorizontalHall(Hall2)
        Hall5.addHorizontalHall(Hall4)
        Hall4.addHorizontalHall(Hall5)
        Hall1.addVerticalHall(Hall5)
        Hall2.addVerticalHall(Hall5)
        Hall2.addVerticalHall(Hall4)
        Hall3.addVerticalHall(Hall4)
        Hall5.addVerticalHall(Hall1)
        Hall5.addVerticalHall(Hall2)
        Hall4.addVerticalHall(Hall3)
        Hall4.addVerticalHall(Hall2)


    const AllHalls = [
        Hall1,Hall2,Hall3,Hall4,Hall5
   ]
        let json;
    function handleSubmit(event) {
        event.preventDefault(); // Prevent the default form submission
        // Get the values from the input fields
        const hall1 = Number(document.getElementById('hall1').value);
        const hall2 = document.getElementById('hall2').value ? document.getElementById('hall2').value :null ;
        const end = document.getElementById('end').value;
        const coords= end.split(',')
        renderMap(hall1,Number(hall2),coords[0],coords[1])
    }

    function fetchJSONData() {
        return fetch("./test.json")
            .then((res) => {
                if (!res.ok) {
                    throw new Error(`HTTP error! Status: ${res.status}`);
                }
                return res.json();
            })
            .then((data) => {

                return data; // Return the data for further processing
            })
            .catch((error) => {
                console.error("Unable to fetch data:", error);
                throw error; // Re-throw the error for the caller to handle
            });
    }

        function MergeArrayH(arr1, arr2) {

        const startpoint_one_left = []
        const startpoint_one_right = []
        const startpoint_two_left = []
        const startpoint_two_right = []
        //Check for exit/entry  (1's) points on the left and right of arr1
        for (let i = 0; i < arr1.length; i++) {
            for (let j = 0; j <arr1[i].length; j++) {
                if(j===0 && arr1[i][j]===1) {
                    startpoint_one_left.push([i,j])
                }
                if(j===arr1[i].length-1 && arr1[i][j]===1) {
                    startpoint_one_right.push([i,j])
                }
            }
        }
        //Check for exit/entry (1's) points on the left and right of arr2
        for (let i = 0; i <arr2.length; i++) {
            for (let j = 0; j <arr2[i].length; j++) {
                if(j===0 && arr2[i][j]===1) {
                    startpoint_two_left.push([i,j])
                }
                if(j===arr2[i].length-1 && arr2[i][j]===1) {
                    startpoint_two_right.push([i,j])
                }
            }
        }
        let reOne = arr1
        let reTwo = arr2
       if(!startpoint_one_right.map(subArray => subArray[0])
           .some(item => startpoint_two_left.map(subArray => subArray[0])
               .includes(item))){
           reOne = arr2
           reTwo = arr1
       }
        const nGraph = [];
            for (let i = 0; i < Math.max(reOne.length, reTwo.length); i++) {
                nGraph.push([
                    ...(reOne[i] || []),
                    ...(reTwo[i] || [])
                ]);
            }
        return nGraph;
    }
        function checkWalls(arr) {
            const left = arr.map(row => row[0]);
            const right = arr.map(row => row[row.length - 1]);
            const top = arr[0];
            const bottom = arr[arr.length - 1];
            // Check if the room is a corner bottom right
            if (!right.some(x => x === 1) && !bottom.some(x => x === 1)) {
                return 0;
            }
            //Top right
            else if (!right.some(x => x === 1) && !top.some(x => x === 1)) {
                return 1;
            }
            //Top left
            else if (!left.some(x => x === 1) && !top.some(x => x === 1)) {
                return 2;
            }
            //Bottom left
            else if (!left.some(x => x === 1) && !bottom.some(x => x === 1)) {
                return 3;
            }
            return -1;
        }
        //Function mostly used to resolve the issue about aligning Hall 2 with either 4 or 5
        function VDoorToDoor(arr1, arr2,h1,h2) {

            const bottomOne = arr2[arr2.length - 1]; // Get the last row of arr2
            const top = arr1[0];
            const leftOne = arr1.map(row => row[0]);
            const rightOne = arr1.map(row => row[row.length - 1]);
            const topR = arr2[0];
            const leftTwo = arr2.map(row => row[0]);
            const rightTwo = arr2.map(row => row[row.length - 1]);

            const idOne = []; // Array to hold the indices
            const idTwo = []
            // Check if any element in the last row is 1
             bottomOne.some((value, index) => {
                if (value === 1) {
                    idOne.push(index); // Store the index if the value is 1
                }
            });
            top.some((value, index) => {
                if (value === 1) {
                    idTwo.push(index); // Store the index if the value is 1
                }
            });
            //Arr1 Has no corners Arr2 has a right corner
            if(!rightTwo.some(x => x === 1) && !topR.some(x => x === 1)){
                if(leftOne.some(x => x === 1) && rightOne.some(x=>x===1))
                {
                    const hHalls = AllHalls.filter((x)=>{if(x.id===h1){return x}})[0].horizontalHalls
                        const h = hHalls.filter(x=>x.verticalHalls.some((j)=> {
                            if(j.id === h2){
                                return j
                            }
                        }))
                    return -(json[h[0].id][0].length)
                }
            }
            //Arr1 Has no corners Arr2 has a left corner
            if(!leftTwo.some(x => x === 1) && !topR.some(x => x === 1))
            {
                if(leftOne.some(x => x === 1) && rightOne.some(x=>x===1))
                {
                    const hHalls = AllHalls.filter((x)=>{if(x.id===h1){return x}})[0].horizontalHalls
                    const h = hHalls.filter(x=>x.verticalHalls.some((j)=> {
                        if(j.id === h2){
                            return j
                        }
                    }))
                    return json[h[0].id][0].length
                }
            }
        }
        function MergeArrayV(arr1, arr2,h1,h2) {
            const long_arr = Math.max(arr1.length, arr2.length);
            const maxCols = Math.max(arr1[0]?.length || 0, arr2[0]?.length || 0);
            let merge;
            const check = checkWalls(arr1)
            const checkTwo = checkWalls(arr2)
            const m = VDoorToDoor(arr1,arr2,h1,h2)

            if([2,3].includes(check) && [2,3].includes(checkTwo))
            {
                //When the vertical hall and its connected hall are on the left side
                // Initialize the merged array filled with 3s
                merge =  Array.from({length: long_arr}, () => Array(maxCols).fill(3));
                // Fill with arr2 data first (top rows)
                for (let i = 0; i < arr2.length; i++) {
                    merge[i] = Array(maxCols).fill(3); // Ensure the row exists and is filled with 3s
                    for (let j = 0; j < arr2[i].length; j++) {
                        merge[i][j] = arr2[i][j]; // Copy from arr2
                    }
                }
                // Fill with arr1 data (remaining rows)
                for (let i = 0; i < arr1.length; i++) {
                    // Ensure the row is created if it hasn't been filled by arr2
                    if (!merge[i + arr2.length]) {
                        merge[i + arr2.length] = Array(maxCols).fill(3);
                    }
                    for (let j = 0; j < arr1[i].length; j++) {
                        merge[i + arr2.length][j] = arr1[i][j]; // Copy from arr1
                    }
                }
            }
            if ([-1].includes(check) && [1, 2].includes(checkTwo)) {
                let sI ; // Starting index for arr2 insertion.
                // Ensure sI is calculated based on m
                sI = m < 0 ? arr2[0].length - arr1[0].length + m : m;
                // Calculate the max number of columns needed
                const maxColsRequired = Math.max(arr2[0]?.length || 0, arr1[0]?.length || 0) + Math.abs(m);
                // Create a merge array large enough to accommodate both arrays
                merge = Array.from({ length: arr2.length + arr1.length }, () => Array(maxColsRequired).fill(3));
                // Fill the merge array with arr2 data first (top rows)
                for (let i = 0; i < arr2.length; i++) {
                    for (let j = 0; j < arr2[i].length; j++) {
                        merge[i][j] = arr2[i][j]; // Copy from arr2 from right to left
                    }
                }
                // Fill with arr1 data (remaining rows)
                for (let i = 0; i < arr1.length; i++) {
                    // Ensure the row is created if it hasn't been filled by arr2
                    if (!merge[i + arr2.length]) {
                        merge[i + arr2.length] = Array(maxColsRequired).fill(3);
                    }
                    // Insert arr1 data, adjusting for sI
                    for (let j = 0; j < arr1[i].length; j++) {
                        // Insert elements from arr1 at position [i + arr2.length][sI + j]
                        if (sI + j < maxColsRequired) {
                            merge[i + arr2.length][sI + j] = arr1[i][j];
                        }
                    }
                }
            }



            //When the vertical hall and its connected hall are on the right side
            else if([0].includes(check) && [1].includes(checkTwo))
            {
                merge = Array.from({ length: long_arr }, () => Array(maxCols).fill(3));
                // Fill with arr2 data first (top rows)
                for (let i = 0; i < arr2.length; i++) {
                    merge[i] = Array(maxCols).fill(3); // Ensure the row exists and is filled with 3s
                    for (let j = 0; j < arr2[i].length; j++) {
                        merge[i][j] = arr2[i][j]; // Copy from arr2 from right to left
                    }
                }
                // Fill with arr1 data (remaining rows)
                for (let i = 0; i < arr1.length ; i++) {
                    // Ensure the row is created if it hasn't been filled by arr2
                    if (!merge[i + arr2.length]) {
                        merge[i + arr2.length] = Array(maxCols).fill(3);
                    }
                    for (let j = 0; j < arr1[i].length; j++) {
                        merge[i + arr2.length ][j+arr2.length] = arr1[i][j];
                    }
                }
            }
            return merge;
        }
        function loopNeighboursHorizontal(start, goal, visited = new Set()) {
            // Check if the current node matches the goal
            if (start.id === goal) {

                return true;
            }
            // Mark this node as visited
            visited.add(start.id);
            // Iterate through all horizontal halls
            for (let i = 0; i < start.horizontalHalls.length; i++) {
                const n = start.horizontalHalls[i];
                // Check if the neighbor has already been visited
                if (!visited.has(n.id)) {
                    // Recursively check each neighbor
                    if (loopNeighboursHorizontal(n, goal, visited)) {
                        return true; // If any neighbor matches, return true
                    }
                }
            }
            return false; // Return false if no matches found
        }

        function checkGraph(allHalls, start, goal = null) {
            if (goal)
                for (const hall of AllHalls) {

                    if (hall.id === start) {
                        if (hall.verticalHalls && hall.verticalHalls.some(h => h.id === goal)) {

                            return 1; // Found in vertical halls
                        } else if (loopNeighboursHorizontal(hall,goal)) {
                            return 0; // Horizontal Connection between halls
                        }
                        return -1; // Start hall found, but goal not found
                    }
                }
            else{
                return 0
            }

            return 2; // Start hall not found
        }
        function renderMap(hall1,hall2=null,x,y)
        {
        document.getElementById('grid-container').innerHTML = '';
        const startTime = performance.now();
        let mergedGraph = null;
        fetchJSONData().then(allHalls=>{
            if(allHalls)
            {
                json = allHalls
                const v = checkGraph(allHalls,hall1,hall2)

                //0 == Direct horizontal connection
                if(v===0) {

                    // If the required position is in a singular hall
                    if (hall2 === null || hall2 === 0 &&!mergedGraph) {
                        const gridContainer = document.getElementById('grid-container');
                        mergedGraph = allHalls[hall1]
                        gridContainer.style.gridTemplateColumns = `repeat(${mergedGraph[0].length}, 20px)`;
                    }
                    //Ensure a horizontal path over longer distances
                    if (hall2 - 1 > hall1 || hall1 > hall2 + 1 && !mergedGraph) {

                        const all_graphs = hall1 > hall2 ? Object.keys(allHalls).map(Number).filter(x => x >= hall2 && x <= hall1)
                            : Object.keys(allHalls).map(Number).filter(x => x >= hall1 && x <= hall2)
                        mergedGraph = allHalls[all_graphs[0]];
                        for (let i = 1; i < all_graphs.length; i++) {
                            mergedGraph = MergeArrayH(mergedGraph, allHalls[all_graphs[i]]);
                        }
                        const len = mergedGraph[0].length
                        const gridContainer = document.getElementById('grid-container');
                        gridContainer.style.gridTemplateColumns = `repeat(${len}, 20px) `;
                    }
                    //If the user has to travel a nearby horizontal hall
                    if (!mergedGraph) {
                        const gridContainer = document.getElementById('grid-container');
                        mergedGraph = MergeArrayH(allHalls[hall1], allHalls[hall2])
                        gridContainer.style.gridTemplateColumns = `repeat(${mergedGraph[0].length}, 20px)`;
                    }

                }
                // 1 == Direct vertical connection
                if (v===1 &&mergedGraph===null) {
                    mergedGraph = MergeArrayV(allHalls[hall1],allHalls[hall2],hall1,hall2)
                    const gridContainer = document.getElementById('grid-container');
                    const len = mergedGraph[0].length
                    gridContainer.style.gridTemplateColumns = `repeat(${ len}, 20px) `;
                }

                const graph = new Graph(mergedGraph)
                const start = graph.grid[1][2];
                const end = graph.grid[x][y];
                const result = astar.search(graph, start, end);
                const coords = result.map(point => [point.x, point.y]);
                const toAdd = document.createDocumentFragment();
                for (let i = 0; i < graph.grid.length; i++) {
                    for (let j = 0; j < graph.grid[0].length; j++) {
                        if (coords.some(set => set[0] === i && set[1] === j)) {
                            const newDiv = document.createElement('div');
                            newDiv.className = 'path';
                            toAdd.appendChild(newDiv);
                        }
                        else
                        {
                            switch(graph.grid[i][j].weight)
                            {
                                case 0:
                                    const newDiv0 = document.createElement('div');
                                    newDiv0.className = 'shelf';
                                    toAdd.appendChild(newDiv0);
                                    break;
                                case 2:
                                    const newDiv2 = document.createElement('div');
                                    newDiv2.className = 'wall ';
                                    toAdd.appendChild(newDiv2);
                                    break;
                                case 3:
                                    const newDiv3 = document.createElement('div');
                                    newDiv3.className = 'none';
                                    toAdd.appendChild(newDiv3);
                                    break;
                                default:
                                    const newDivD = document.createElement('div');
                                    newDivD.className = 'square';
                                    toAdd.appendChild(newDivD);
                                    break;
                            }
                        }
                    }
                }
                document.getElementById('grid-container').innerHTML = '';
                document.getElementById('grid-container').appendChild(toAdd);
            }
        })
            const endTime = performance.now();

            console.log(`Call to doSomething took ${endTime - startTime} milliseconds`)
        }

    document.getElementById('inputForm').addEventListener('submit', handleSubmit);

</script>



</body>
</html>
