(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";var __exports__=(()=>{var li=Object.create;var De=Object.defineProperty;var ci=Object.getOwnPropertyDescriptor;var ui=Object.getOwnPropertyNames;var gi=Object.getPrototypeOf,fi=Object.prototype.hasOwnProperty;var Xe=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),di=(n,e)=>{for(var t in e)De(n,t,{get:e[t],enumerable:!0})},Ne=(n,e,t,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of ui(e))!fi.call(n,i)&&i!==t&&De(n,i,{get:()=>e[i],enumerable:!(o=ci(e,i))||o.enumerable});return n},B=(n,e,t)=>(Ne(n,e,"default"),t&&Ne(t,e,"default")),M=(n,e,t)=>(t=n!=null?li(gi(n)):{},Ne(e||!n||!n.__esModule?De(t,"default",{value:n,enumerable:!0}):t,n)),pi=n=>Ne(De({},"__esModule",{value:!0}),n);var X=Xe((Pr,ct)=>{ct.exports=globalThis.deck});var E=Xe((Dr,gt)=>{gt.exports=globalThis.deck});var k=Xe((Lr,ft)=>{ft.exports=globalThis.luma});var Pe={};di(Pe,{AGGREGATION_OPERATION:()=>T,CPUGridLayer:()=>Se,ContourLayer:()=>Go,GPUGridLayer:()=>Te,GridLayer:()=>Yo,HeatmapLayer:()=>si,HexagonLayer:()=>ao,ScreenGridLayer:()=>Kt,_AggregationLayer:()=>O,_BinSorter:()=>F,_CPUAggregator:()=>w,_GPUGridAggregator:()=>C});var L={},ut=M(X(),1);B(L,M(X(),1));if(!ut.GeoJsonLayer)throw new Error("@deck.gl/layers is not found");B(Pe,L);var $t=M(E(),1);var me=M(k(),1);function qe(n,e=[],t=0){let o=Math.fround(n),i=n-o;return e[t]=o,e[t+1]=i,e}function dt(n){return n-Math.fround(n)}function pt(n){let e=new Float32Array(32);for(let t=0;t<4;++t)for(let o=0;o<4;++o){let i=t*4+o;qe(n[o*4+t],e,i*2)}return e}var mt=`uniform float ONE;
vec2 split(float a) {
const float SPLIT = 4097.0;
float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float a_hi = t * ONE - (t - a);
float a_lo = a * ONE - a_hi;
#else
float a_hi = t - (t - a);
float a_lo = a - a_hi;
#endif
return vec2(a_hi, a_lo);
}
vec2 split2(vec2 a) {
vec2 b = split(a.x);
b.y += a.y;
return b;
}
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float sum = (a + b) * ONE;
float err = b - (sum - a) * ONE;
#else
float sum = a + b;
float err = b - (sum - a);
#endif
return vec2(sum, err);
}
vec2 twoSum(float a, float b) {
float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
float v = s - a;
float err = (a - (s - v)) + (b - v);
#endif
return vec2(s, err);
}
vec2 twoSub(float a, float b) {
float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
float v = s - a;
float err = (a - (s - v)) - (b + v);
#endif
return vec2(s, err);
}
vec2 twoSqr(float a) {
float prod = a * a;
vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
return vec2(prod, err);
}
vec2 twoProd(float a, float b) {
float prod = a * b;
vec2 a_fp64 = split(a);
vec2 b_fp64 = split(b);
float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
return vec2(prod, err);
}
vec2 sum_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSum(a.x, b.x);
t = twoSum(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 sub_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSub(a.x, b.x);
t = twoSub(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 mul_fp64(vec2 a, vec2 b) {
vec2 prod = twoProd(a.x, b.x);
prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
return prod;
}
vec2 div_fp64(vec2 a, vec2 b) {
float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
vec2 yn = a * xn;
#endif
float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
vec2 prod = twoProd(xn, diff);
return sum_fp64(yn, prod);
}
vec2 sqrt_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
float x = 1.0 / sqrt(a.x);
float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
vec2 yn_sqr = twoSqr(yn) * ONE;
#else
vec2 yn_sqr = twoSqr(yn);
#endif
float diff = sub_fp64(a, yn_sqr).x;
vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
return sum_fp64(split(yn), prod);
#else
return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`;var mi={ONE:1};function hi(){return mi}var q={name:"fp64-arithmetic",vs:mt,getUniforms:hi,fp64ify:qe,fp64LowPart:dt,fp64ifyMatrix4:pt};var K=M(E(),1);var T={SUM:1,MEAN:2,MIN:3,MAX:4};function ht(n,e){return n+e}function xi(n,e){return e>n?e:n}function vi(n,e){return e<n?e:n}function Si(n,e){if(Number.isFinite(e))return n.length?e:null;let t=n.map(e).filter(Number.isFinite);return t.length?t.reduce(ht,0)/t.length:null}function yi(n,e){if(Number.isFinite(e))return n.length?n.length*e:null;let t=n.map(e).filter(Number.isFinite);return t.length?t.reduce(ht,0):null}function Ai(n,e){if(Number.isFinite(e))return n.length?e:null;let t=n.map(e).filter(Number.isFinite);return t.length?t.reduce(xi,-1/0):null}function _i(n,e){if(Number.isFinite(e))return n.length?e:null;let t=n.map(e).filter(Number.isFinite);return t.length?t.reduce(vi,1/0):null}function Y(n,e,t){let o=T[n]||T.SUM;switch(e=bi(e,t),o){case T.MIN:return i=>_i(i,e);case T.SUM:return i=>yi(i,e);case T.MEAN:return i=>Si(i,e);case T.MAX:return i=>Ai(i,e);default:return null}}function bi(n,e={}){return Number.isFinite(n)?n:t=>(e.index=t.index,n(t.source,e))}function xt(n,e={}){return t=>(e.indices=t.map(o=>o.index),n(t.map(o=>o.source),e))}var vt={projectPoints:!1,viewport:null,createBufferObjects:!0,moduleSettings:{}},U=3402823466e29,Ye=[32775,32774],$e=[32776,32774],St=[32776,32775],Ke={[T.SUM]:32774,[T.MEAN]:32774,[T.MIN]:Ye,[T.MAX]:$e};var yt={size:1,operation:T.SUM,needMin:!1,needMax:!1,combineMaxMin:!1},At=4;var _t=`#version 300 es
#define SHADER_NAME gpu-aggregation-to-grid-vs
in vec3 positions;
in vec3 positions64Low;
in vec3 weights;
uniform vec2 cellSize;
uniform vec2 gridSize;
uniform bool projectPoints;
uniform vec2 translation;
uniform vec3 scaling;
out vec3 vWeights;
vec2 project_to_pixel(vec4 pos) {
vec4 result;
pos.xy = pos.xy/pos.w;
result = pos + vec4(translation, 0., 0.);
result.xy = scaling.z > 0. ? result.xy * scaling.xy : result.xy;
return result.xy;
}
void main(void) {
vWeights = weights;
vec4 windowPos = vec4(positions, 1.);
if (projectPoints) {
windowPos = project_position_to_clipspace(positions, positions64Low, vec3(0));
}
vec2 pos = project_to_pixel(windowPos);
vec2 pixelXY64[2];
pixelXY64[0] = vec2(pos.x, 0.);
pixelXY64[1] = vec2(pos.y, 0.);
vec2 gridXY64[2];
gridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));
gridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));
float x = floor(gridXY64[0].x);
float y = floor(gridXY64[1].x);
pos = vec2(x, y);
pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);
vec2 offset = 1.0 / gridSize;
pos = pos + offset;
gl_Position = vec4(pos, 0.0, 1.0);
gl_PointSize = 1.0;
}
`;var bt=`#version 300 es
#define SHADER_NAME gpu-aggregation-to-grid-fs
precision highp float;
in vec3 vWeights;
out vec4 fragColor;
void main(void) {
fragColor = vec4(vWeights, 1.0);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Mt=`#version 300 es
#define SHADER_NAME gpu-aggregation-all-vs-64
in vec2 position;
uniform ivec2 gridSize;
out vec2 vTextureCoord;
void main(void) {
vec2 pos = vec2(-1.0, -1.0);
vec2 offset = 1.0 / vec2(gridSize);
pos = pos + offset;
gl_Position = vec4(pos, 0.0, 1.0);
int yIndex = gl_InstanceID / gridSize[0];
int xIndex = gl_InstanceID - (yIndex * gridSize[0]);
vec2 yIndexFP64 = vec2(float(yIndex), 0.);
vec2 xIndexFP64 = vec2(float(xIndex), 0.);
vec2 gridSizeYFP64 = vec2(gridSize[1], 0.);
vec2 gridSizeXFP64 = vec2(gridSize[0], 0.);
vec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);
vec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);
vTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);
gl_PointSize = 1.0;
}
`;var Tt=`#version 300 es
#define SHADER_NAME gpu-aggregation-all-fs
precision highp float;
in vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform bool combineMaxMin;
out vec4 fragColor;
void main(void) {
vec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
if (textureColor.a == 0.) {
discard;
}
fragColor.rgb = textureColor.rgb;
fragColor.a = combineMaxMin ? textureColor.r : textureColor.a;
}
`;var Ct=`#version 300 es
#define SHADER_NAME gpu-aggregation-transform-mean-vs
in vec4 aggregationValues;
out vec4 meanValues;
void main()
{
bool isCellValid = bool(aggregationValues.w > 0.);
meanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);
meanValues.w = aggregationValues.w;
gl_PointSize = 1.0;
}
`;var Mi={minFilter:"nearest",magFilter:"nearest"};function $(n,e){let{width:t=1,height:o=1,data:i=null,parameters:r=Mi}=e;return n.createTexture({data:i,format:"rgba32float",mipmaps:!1,sampler:r,width:t,height:o})}function pe(n,e){let{id:t,width:o=1,height:i=1,texture:r}=e;return n.createFramebuffer({id:t,width:o,height:i,colorAttachments:[r]})}var Ti=["aggregationBuffer","maxMinBuffer","minBuffer","maxBuffer"],Et={maxData:"maxBuffer",minData:"minBuffer",maxMinData:"maxMinBuffer"},Ci=["float32-renderable-webgl","texture-blend-float-webgl"],C=class{static getAggregationData({aggregationData:e,maxData:t,minData:o,maxMinData:i,pixelIndex:r}){let a=r*At,s={};return e&&(s.cellCount=e[a+3],s.cellWeight=e[a]),i?(s.maxCellWieght=i[0],s.minCellWeight=i[3]):(t&&(s.maxCellWieght=t[0],s.totalCount=t[3]),o&&(s.minCellWeight=o[0],s.totalCount=o[3])),s}static getCellData({countsData:e,size:t=1}){let o=e.length/4,i=new Float32Array(o*t),r=new Uint32Array(o);for(let a=0;a<o;a++){for(let s=0;s<t;s++)i[a*t+s]=e[a*4+s];r[a]=e[a*4+3]}return{cellCounts:r,cellWeights:i}}static isSupported(e){return Ci.every(t=>e.features.has(t))}constructor(e,t={}){this.state={weightAttributes:{},textures:{},meanTextures:{},buffers:{},framebuffers:{},maxMinFramebuffers:{},minFramebuffers:{},maxFramebuffers:{},equations:{},shaderOptions:{},modelDirty:!1,resources:{},results:{}},this.id=t.id||"gpu-grid-aggregator",this.device=e;let o=["float32-renderable-webgl"];this._hasGPUSupport=o.every(i=>e.features.has(i)),this._hasGPUSupport&&this._setupModels()}delete(){let{gridAggregationModel:e,allAggregationModel:t,meanTransform:o}=this,{textures:i,framebuffers:r,maxMinFramebuffers:a,minFramebuffers:s,maxFramebuffers:l,meanTextures:c,resources:g}=this.state;e?.destroy(),t?.destroy(),o?.destroy(),Pi([r,i,a,s,l,c,g])}run(e={}){this.setState({results:{}});let t=this._normalizeAggregationParams(e);return this._runAggregation(t)}getData(e){let t={},o=this.state.results;o[e].aggregationData||(o[e].aggregationData=o[e].aggregationBuffer.getData()),t.aggregationData=o[e].aggregationData;for(let i in Et){let r=Et[i];(o[e][i]||o[e][r])&&(o[e][i]=o[e][i]||o[e][r].getData(),t[i]=o[e][i])}return t}updateShaders(e={}){this.setState({shaderOptions:e,modelDirty:!0})}_normalizeAggregationParams(e){let t={...vt,...e},{weights:o}=t;return o&&(t.weights=Ei(o)),t}setState(e){Object.assign(this.state,e)}_getAggregateData(e){let t={},{textures:o,framebuffers:i,maxMinFramebuffers:r,minFramebuffers:a,maxFramebuffers:s,resources:l}=this.state,{weights:c}=e;for(let g in c){t[g]={};let{needMin:f,needMax:d,combineMaxMin:p}=c[g];t[g].aggregationTexture=o[g],t[g].aggregationBuffer=this.device.readPixelsToBufferWebGL(i[g],{target:c[g].aggregationBuffer,sourceType:5126}),f&&d&&p?(t[g].maxMinBuffer=this.device.readPixelsToBufferWebGL(r[g],{target:c[g].maxMinBuffer,sourceType:5126}),t[g].maxMinTexture=l[`${g}-maxMinTexture`]):(f&&(t[g].minBuffer=this.device.readPixelsToBufferWebGL(a[g],{target:c[g].minBuffer,sourceType:5126}),t[g].minTexture=l[`${g}-minTexture`]),d&&(t[g].maxBuffer=this.device.readPixelsToBufferWebGL(s[g],{target:c[g].maxBuffer,sourceType:5126}),t[g].maxTexture=l[`${g}-maxTexture`]))}return this._trackGPUResultBuffers(t,c),t}_renderAggregateData(e){let{cellSize:t,projectPoints:o,attributes:i,moduleSettings:r,numCol:a,numRow:s,weights:l,translation:c,scaling:g}=e,{maxMinFramebuffers:f,minFramebuffers:d,maxFramebuffers:p}=this.state,x=[a,s],h={blend:!0,depthTest:!1,blendFunc:[1,1]},y={cellSize:t,gridSize:x,projectPoints:o,translation:c,scaling:g};for(let S in l){let{needMin:A,needMax:_}=l[S],b=A&&_&&l[S].combineMaxMin;this._renderToWeightsTexture({id:S,parameters:h,moduleSettings:r,uniforms:y,gridSize:x,attributes:i,weights:l}),b?this._renderToMaxMinTexture({id:S,parameters:{...h,blendEquation:St},gridSize:x,minOrMaxFb:f[S],clearParams:{clearColor:[0,0,0,U]},combineMaxMin:b}):(A&&this._renderToMaxMinTexture({id:S,parameters:{...h,blendEquation:Ye},gridSize:x,minOrMaxFb:d[S],clearParams:{clearColor:[U,U,U,0]},combineMaxMin:b}),_&&this._renderToMaxMinTexture({id:S,parameters:{...h,blendEquation:$e},gridSize:x,minOrMaxFb:p[S],clearParams:{clearColor:[0,0,0,0]},combineMaxMin:b}))}}_renderToMaxMinTexture(e){let{id:t,gridSize:o,minOrMaxFb:i,combineMaxMin:r,clearParams:a={}}=e,{framebuffers:s}=this.state,{allAggregationModel:l}=this;this.device.withParametersWebGL({...a,framebuffer:i,viewport:[0,0,o[0],o[1]]},()=>{this.device.clearWebGL({color:!0}),l.setUniforms({gridSize:o,combineMaxMin:r}),l.setBindings({uSampler:s[t].texture}),l.draw()})}_renderToWeightsTexture(e){let{id:t,parameters:o,moduleSettings:i,uniforms:r,gridSize:a,weights:s}=e,{framebuffers:l,equations:c,weightAttributes:g}=this.state,{gridAggregationModel:f}=this,{operation:d}=s[t],p=d===T.MIN?[U,U,U,0]:[0,0,0,0];if(this.device.withParametersWebGL({framebuffer:l[t],viewport:[0,0,a[0],a[1]],clearColor:p},()=>{this.device.clearWebGL({color:!0});let x={weights:g[t]};f.draw({parameters:{...o,blendEquation:c[t]},moduleSettings:i,uniforms:r,attributes:x})}),d===T.MEAN){let{meanTextures:x,textures:h}=this.state,y={_sourceTextures:{aggregationValues:x[t]},_targetTexture:h[t],elementCount:h[t].width*h[t].height};this.meanTransform?this.meanTransform.update(y):this.meanTransform=Li(this.device,y),this.meanTransform.run({parameters:{blend:!1,depthTest:!1}}),l[t].attach({[36064]:h[t]})}}_runAggregation(e){this._updateModels(e),this._setupFramebuffers(e),this._renderAggregateData(e);let t=this._getAggregateData(e);return this.setState({results:t}),t}_setupFramebuffers(e){let{textures:t,framebuffers:o,maxMinFramebuffers:i,minFramebuffers:r,maxFramebuffers:a,meanTextures:s,equations:l}=this.state,{weights:c}=e,{numCol:g,numRow:f}=e,d={width:g,height:f};for(let p in c){let{needMin:x,needMax:h,combineMaxMin:y,operation:S}=c[p];t[p]=c[p].aggregationTexture||t[p]||$(this.device,{id:`${p}-texture`,width:g,height:f}),t[p].resize(d);let A=t[p];S===T.MEAN&&(s[p]=s[p]||$(this.device,{id:`${p}-mean-texture`,width:g,height:f}),s[p].resize(d),A=s[p]),o[p]?o[p].attach({[36064]:A}):o[p]=pe(this.device,{id:`${p}-fb`,width:g,height:f,texture:A}),o[p].resize(d),l[p]=Ke[S]||Ke[T.SUM],(x||h)&&(x&&h&&y?i[p]||(A=c[p].maxMinTexture||this._getMinMaxTexture(`${p}-maxMinTexture`),i[p]=pe(this.device,{id:`${p}-maxMinFb`,texture:A})):(x&&(r[p]||(A=c[p].minTexture||this._getMinMaxTexture(`${p}-minTexture`),r[p]=pe(this.device,{id:`${p}-minFb`,texture:A}))),h&&(a[p]||(A=c[p].maxTexture||this._getMinMaxTexture(`${p}-maxTexture`),a[p]=pe(this.device,{id:`${p}-maxFb`,texture:A})))))}}_getMinMaxTexture(e){let{resources:t}=this.state;return t[e]||(t[e]=$(this.device,{id:"resourceName"})),t[e]}_setupModels({numCol:e=0,numRow:t=0}={}){let{shaderOptions:o}=this.state;if(this.gridAggregationModel?.destroy(),this.gridAggregationModel=Ni(this.device,o),!this.allAggregationModel){let i=e*t;this.allAggregationModel=Di(this.device,i)}}_setupWeightAttributes(e){let{weightAttributes:t}=this.state,{weights:o}=e;for(let i in o)t[i]=e.attributes[i]}_trackGPUResultBuffers(e,t){let{resources:o}=this.state;for(let i in e)if(e[i]){for(let r of Ti)if(e[i][r]&&t[i][r]!==e[i][r]){let a=`gpu-result-${i}-${r}`;o[a]&&o[a].delete(),o[a]=e[i][r]}}}_updateModels(e){let{vertexCount:t,attributes:o,numCol:i,numRow:r}=e,{modelDirty:a}=this.state;a&&(this._setupModels(e),this.setState({modelDirty:!1})),this._setupWeightAttributes(e),this.gridAggregationModel.setVertexCount(t),this.gridAggregationModel.setAttributes(o),this.allAggregationModel.setInstanceCount(i*r)}};function Ei(n){let e={};for(let t in n)e[t]={...yt,...n[t]};return e}function Pi(n){n=Array.isArray(n)?n:[n],n.forEach(e=>{for(let t in e)e[t].delete()})}function Ni(n,e){let t=(0,K._mergeShaders)({vs:_t,fs:bt,modules:[q,K.project32]},e);return new me.Model(n,{id:"Grid-Aggregation-Model",vertexCount:1,drawMode:0,shaderAssembler:(0,K.getShaderAssembler)(),...t})}function Di(n,e){return new me.Model(n,{id:"All-Aggregation-Model",vs:Mt,fs:Tt,modules:[q],vertexCount:1,topology:"point-list",isInstanced:!0,instanceCount:e,attributes:{position:[0,0]}})}function Li(n,e){return new me.TextureTransform(n,{vs:Ct,_targetTextureVarying:"meanValues",...e})}var Le=M(k(),1),Q=M(E(),1);var N=[[255,255,178],[254,217,118],[254,178,76],[253,141,60],[240,59,32],[189,0,38]];function G(n,e=!1,t=Float32Array){let o;if(Number.isFinite(n[0]))o=new t(n);else{o=new t(n.length*4);let i=0;for(let r=0;r<n.length;r++){let a=n[r];o[i++]=a[0],o[i++]=a[1],o[i++]=a[2],o[i++]=Number.isFinite(a[3])?a[3]:255}}if(e)for(let i=0;i<o.length;i++)o[i]/=255;return o}var Pt=`#version 300 es
#define SHADER_NAME screen-grid-layer-vertex-shader
#define RANGE_COUNT 6
in vec3 positions;
in vec3 instancePositions;
in vec4 instanceCounts;
in vec3 instancePickingColors;
uniform float opacity;
uniform vec3 cellScale;
uniform vec4 minColor;
uniform vec4 maxColor;
uniform vec4 colorRange[RANGE_COUNT];
uniform vec2 colorDomain;
uniform bool shouldUseMinMax;
uniform sampler2D maxTexture;
out vec4 vColor;
out float vSampleCount;
vec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {
vec4 outColor = vec4(0., 0., 0., 0.);
if (value >= domain.x && value <= domain.y) {
float domainRange = domain.y - domain.x;
if (domainRange <= 0.) {
outColor = colorRange[0];
} else {
float rangeCount = float(RANGE_COUNT);
float rangeStep = domainRange / rangeCount;
float idx = floor((value - domain.x) / rangeStep);
idx = clamp(idx, 0., rangeCount - 1.);
int intIdx = int(idx);
outColor = colorRange[intIdx];
}
}
outColor = outColor / 255.;
return outColor;
}
void main(void) {
vSampleCount = instanceCounts.a;
float weight = instanceCounts.r;
float maxWeight = texture(maxTexture, vec2(0.5)).r;
float step = weight / maxWeight;
vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;
vec2 domain = colorDomain;
float domainMaxValid = float(colorDomain.y != 0.);
domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);
vec4 rangeColor = quantizeScale(domain, colorRange, weight);
float rangeMinMax = float(shouldUseMinMax);
vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);
vColor = vec4(color.rgb, color.a * opacity);
picking_setPickingColor(instancePickingColors);
gl_Position = vec4(instancePositions + positions * cellScale, 1.);
}
`;var Nt=`#version 300 es
#define SHADER_NAME screen-grid-layer-fragment-shader
precision highp float;
in vec4 vColor;
in float vSampleCount;
out vec4 fragColor;
void main(void) {
if (vSampleCount <= 0.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Oi=[0,0,0,0],Fi=[0,255,0,255],wi=["minColor","maxColor","colorRange","colorDomain"],Ii={cellSizePixels:{type:"number",value:100,min:1},cellMarginPixels:{type:"number",value:2,min:0,max:5},colorDomain:null,colorRange:N},he=class extends Q.Layer{getShaders(){return{vs:Pt,fs:Nt,modules:[Q.picking]}}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,update:this.calculateInstancePositions},instanceCounts:{size:4,noAlloc:!0}}),this.setState({model:this._getModel()})}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState(e){super.updateState(e);let{oldProps:t,props:o,changeFlags:i}=e,r=this.getAttributeManager();o.numInstances!==t.numInstances?r.invalidateAll():t.cellSizePixels!==o.cellSizePixels&&r.invalidate("instancePositions"),this._updateUniforms(t,o,i)}draw({uniforms:e}){let{parameters:t,maxTexture:o}=this.props,i=this.props.minColor||Oi,r=this.props.maxColor||Fi,a=this.props.colorDomain||[1,0],s=this.state.model;s.setUniforms(e),s.setBindings({maxTexture:o}),s.setUniforms({minColor:i,maxColor:r,colorDomain:a}),s.setParameters({depthWriteEnabled:!1,...t}),s.draw(this.context.renderPass)}calculateInstancePositions(e,{numInstances:t}){let{width:o,height:i}=this.context.viewport,{cellSizePixels:r}=this.props,a=Math.ceil(o/r),{value:s,size:l}=e;for(let c=0;c<t;c++){let g=c%a,f=Math.floor(c/a);s[c*l+0]=g*r/o*2-1,s[c*l+1]=1-f*r/i*2,s[c*l+2]=0}}_getModel(){return new Le.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new Le.Geometry({topology:"triangle-list",attributes:{positions:new Float32Array([0,0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,0])}}),isInstanced:!0})}_shouldUseMinMax(){let{minColor:e,maxColor:t,colorDomain:o,colorRange:i}=this.props;return e||t?(Q.log.deprecated("ScreenGridLayer props: minColor and maxColor","colorRange, colorDomain")(),!0):!(o||i)}_updateUniforms(e,t,o){let i=this.state.model;if(wi.some(r=>e[r]!==t[r])&&i.setUniforms({shouldUseMinMax:this._shouldUseMinMax()}),e.colorRange!==t.colorRange&&i.setUniforms({colorRange:G(t.colorRange)}),e.cellMarginPixels!==t.cellMarginPixels||e.cellSizePixels!==t.cellSizePixels||o.viewportChanged){let{width:r,height:a}=this.context.viewport,{cellSizePixels:s,cellMarginPixels:l}=this.props,c=s>l?l:0,g=new Float32Array([(s-c)/r*2,-(s-c)/a*2,1]);i.setUniforms({cellScale:g})}}};he.layerName="ScreenGridCellLayer";he.defaultProps=Ii;var Qe=he;var qt=M(E(),1);var Z=M(E(),1);function Dt(n,e){let t={};for(let o in n)e.includes(o)||(t[o]=n[o]);return t}var Oe=class extends Z.CompositeLayer{initializeAggregationLayer(e){super.initializeState(this.context),this.setState({ignoreProps:Dt(this.constructor._propTypes,e.data.props),dimensions:e})}updateState(e){super.updateState(e);let{changeFlags:t}=e;if(t.extensionsChanged){let o=this.getShaders({});o&&o.defines&&(o.defines.NON_INSTANCED_MODEL=1),this.updateShaders(o)}this._updateAttributes()}updateAttributes(e){this.setState({changedAttributes:e})}getAttributes(){return this.getAttributeManager().getAttributes()}getModuleSettings(){let{viewport:e,mousePosition:t,device:o}=this.context;return Object.assign(Object.create(this.props),{viewport:e,mousePosition:t,picking:{isActive:0},devicePixelRatio:o.canvasContext.cssToDeviceRatio()})}updateShaders(e){}isAggregationDirty(e,t={}){let{props:o,oldProps:i,changeFlags:r}=e,{compareAll:a=!1,dimension:s}=t,{ignoreProps:l}=this.state,{props:c,accessors:g=[]}=s,{updateTriggersChanged:f}=r;if(r.dataChanged)return!0;if(f){if(f.all)return!0;for(let d of g)if(f[d])return!0}if(a)return r.extensionsChanged?!0:(0,Z._compareProps)({oldProps:i,newProps:o,ignoreProps:l,propTypes:this.constructor._propTypes});for(let d of c)if(o[d]!==i[d])return!0;return!1}isAttributeChanged(e){let{changedAttributes:t}=this.state;return e?t&&t[e]!==void 0:!Ri(t)}_getAttributeManager(){return new Z.AttributeManager(this.context.device,{id:this.props.id,stats:this.context.stats})}};Oe.layerName="AggregationLayer";var O=Oe;function Ri(n){let e=!0;for(let t in n){e=!1;break}return e}var Ot=M(E(),1);function Fe(n,e,t){let o=t;return o.domain=()=>n,o.range=()=>e,o}function Lt(n,e){return Fe(n,e,o=>ki(n,e,o))}function Bi(n,e){return Fe(n,e,o=>ji(n,e,o))}function Ui(n,e){let t=n.sort(Ft),o=0,i=Math.max(1,e.length),r=new Array(i-1);for(;++o<i;)r[o-1]=Gi(t,o/i);let a=s=>zi(r,e,s);return a.thresholds=()=>r,Fe(n,e,a)}function Ft(n,e){return n-e}function Gi(n,e){let t=n.length;if(e<=0||t<2)return n[0];if(e>=1)return n[t-1];let o=(t-1)*e,i=Math.floor(o),r=n[i],a=n[i+1];return r+(a-r)*(o-i)}function Wi(n,e){let t=0,o=n.length;for(;t<o;){let i=t+o>>>1;Ft(n[i],e)>0?o=i:t=i+1}return t}function zi(n,e,t){return e[Wi(n,t)]}function Hi(n,e,t,o){let i=`${o}`,r=e.get(i);return r===void 0&&(r=n.push(o),e.set(i,r)),t[(r-1)%t.length]}function Vi(n,e){let t=new Map,o=[];for(let r of n){let a=`${r}`;t.has(a)||t.set(a,o.push(r))}return Fe(n,e,r=>Hi(o,t,e,r))}function ki(n,e,t){let o=n[1]-n[0];if(o<=0)return Ot.log.warn("quantizeScale: invalid domain, returning range[0]")(),e[0];let i=o/e.length,r=Math.floor((t-n[0])/i),a=Math.max(Math.min(r,e.length-1),0);return e[a]}function ji(n,e,t){return(t-n[0])/(n[1]-n[0])*(e[1]-e[0])+e[0]}function wt(n){return n!=null}function Xi(n){let e=[];return n.forEach(t=>{!e.includes(t)&&wt(t)&&e.push(t)}),e}function It(n,e){return(typeof e=="function"?n.map(e):n).filter(wt)}function Rt(n,e){return It(n,e)}function Bt(n,e){return Xi(It(n,e))}function Ut(n,e,t){return Math.max(e,Math.min(t,n))}function Gt(n){switch(n){case"quantize":return Lt;case"linear":return Bi;case"quantile":return Ui;case"ordinal":return Vi;default:return Lt}}var zt=n=>n.length,qi=3402823466e29,Ht=n=>n.points,Vt=n=>n.index,Wt=(n,e)=>n<e?-1:n>e?1:n>=e?0:NaN,Yi={getValue:zt,getPoints:Ht,getIndex:Vt,filterData:null},F=class{constructor(e=[],t=Yi){this.aggregatedBins=this.getAggregatedBins(e,t),this._updateMinMaxValues(),this.binMap=this.getBinMap()}getAggregatedBins(e,t){let{getValue:o=zt,getPoints:i=Ht,getIndex:r=Vt,filterData:a}=t,s=typeof a=="function",l=e.length,c=[],g=0;for(let f=0;f<l;f++){let d=e[f],p=i(d),x=r(d),h=s?p.filter(a):p;d.filteredPoints=s?h:null;let y=h.length?o(h):null;y!=null&&(c[g]={i:Number.isFinite(x)?x:f,value:y,counts:h.length},g++)}return c}_percentileToIndex(e){let t=this.sortedBins.length;if(t<2)return[0,0];let[o,i]=e.map(s=>Ut(s,0,100)),r=Math.ceil(o/100*(t-1)),a=Math.floor(i/100*(t-1));return[r,a]}getBinMap(){let e={};for(let t of this.aggregatedBins)e[t.i]=t;return e}_updateMinMaxValues(){let e=0,t=0,o=qi,i=0;for(let r of this.aggregatedBins)e=e>r.counts?e:r.counts,t=t>r.value?t:r.value,o=o<r.value?o:r.value,i+=r.counts;this.maxCount=e,this.maxValue=t,this.minValue=o,this.totalCount=i}getValueRange(e){if(this.sortedBins||(this.sortedBins=this.aggregatedBins.sort((i,r)=>Wt(i.value,r.value))),!this.sortedBins.length)return[];let t=0,o=this.sortedBins.length-1;if(Array.isArray(e)){let i=this._percentileToIndex(e);t=i[0],o=i[1]}return[this.sortedBins[t].value,this.sortedBins[o].value]}getValueDomainByScale(e,[t=0,o=100]=[]){if(this.sortedBins||(this.sortedBins=this.aggregatedBins.sort((r,a)=>Wt(r.value,a.value))),!this.sortedBins.length)return[];let i=this._percentileToIndex([t,o]);return this._getScaleDomain(e,i)}_getScaleDomain(e,[t,o]){let i=this.sortedBins;switch(e){case"quantize":case"linear":return[i[t].value,i[o].value];case"quantile":return Rt(i.slice(t,o+1),r=>r.value);case"ordinal":return Bt(i,r=>r.value);default:return[i[t].value,i[o].value]}}};var Xt=M(E(),1);var W=M(E(),1),jt=6378e3;function we(n){return Number.isFinite(n)?n:0}function Ie(n,e){let t=n.positions.value,o=1/0,i=-1/0,r=1/0,a=-1/0,s,l;for(let g=0;g<e;g++)l=t[g*3],s=t[g*3+1],o=s<o?s:o,i=s>i?s:i,r=l<r?l:r,a=l>a?l:a;return{xMin:we(r),xMax:we(a),yMin:we(o),yMax:we(i)}}function $i(n,e,t,o){let{width:i,height:r}=o,a=t===W.COORDINATE_SYSTEM.CARTESIAN?[-i/2,-r/2]:[-180,-90];W.log.assert(t===W.COORDINATE_SYSTEM.CARTESIAN||t===W.COORDINATE_SYSTEM.LNGLAT||t===W.COORDINATE_SYSTEM.DEFAULT);let{xMin:s,yMin:l}=n;return[-1*(kt(s-a[0],e.xOffset)+a[0]),-1*(kt(l-a[1],e.yOffset)+a[1])]}function kt(n,e){let t=n<0?-1:1,o=t<0?Math.abs(n)+e:Math.abs(n);return o=Math.floor(o/e)*e,o*t}function Ze(n,e,t=!0){if(!t)return{xOffset:e,yOffset:e};let{yMin:o,yMax:i}=n,r=(o+i)/2;return Ki(e,r)}function Re(n,e,t,o){let i=Ze(n,e,o!==W.COORDINATE_SYSTEM.CARTESIAN),r=$i(n,i,o,t),{xMin:a,yMin:s,xMax:l,yMax:c}=n,g=l-a+i.xOffset,f=c-s+i.yOffset,d=Math.ceil(g/i.xOffset),p=Math.ceil(f/i.yOffset);return{gridOffset:i,translation:r,width:g,height:f,numCol:d,numRow:p}}function Ki(n,e){let t=Qi(n),o=Zi(e,n);return{yOffset:t,xOffset:o}}function Qi(n){return n/jt*(180/Math.PI)}function Zi(n,e){return e/jt*(180/Math.PI)/Math.cos(n*Math.PI/180)}function J(n,e){let t=Ji(n,e),o=er(t);return{gridHash:t.gridHash,gridOffset:t.gridOffset,data:o}}function Ji(n,e){let{data:t=[],cellSize:o}=n,{attributes:i,viewport:r,projectPoints:a,numInstances:s}=e,l=i.positions.value,{size:c}=i.positions.getAccessor(),g=e.boundingBox||tr(i.positions,s),f=e.posOffset||[180,90],d=e.gridOffset||Ze(g,o);if(d.xOffset<=0||d.yOffset<=0)return{gridHash:{},gridOffset:d,offsets:[0,0]};let{width:p,height:x}=r,h=Math.ceil(p/d.xOffset),y=Math.ceil(x/d.yOffset),S={},{iterable:A,objectInfo:_}=(0,Xt.createIterable)(t),b=new Array(3);for(let D of A){_.index++,b[0]=l[_.index*c],b[1]=l[_.index*c+1],b[2]=c>=3?l[_.index*c+2]:0;let[R,fe]=a?r.project(b):b;if(Number.isFinite(R)&&Number.isFinite(fe)){let z=Math.floor((fe+f[1])/d.yOffset),H=Math.floor((R+f[0])/d.xOffset);if(!a||H>=0&&H<h&&z>=0&&z<y){let V=`${z}-${H}`;S[V]=S[V]||{count:0,points:[],lonIdx:H,latIdx:z},S[V].count+=1,S[V].points.push({source:D,index:_.index})}}}return{gridHash:S,gridOffset:d,offsets:[f[0]*-1,f[1]*-1]}}function er({gridHash:n,gridOffset:e,offsets:t}){let o=new Array(Object.keys(n).length),i=0;for(let r in n){let a=r.split("-"),s=parseInt(a[0],10),l=parseInt(a[1],10),c=i++;o[c]={index:c,position:[t[0]+e.xOffset*l,t[1]+e.yOffset*s],...n[r]}}return o}function tr(n,e){let t=n.value,{size:o}=n.getAccessor(),i=1/0,r=-1/0,a=1/0,s=-1/0,l,c;for(let g=0;g<e;g++)c=t[g*o],l=t[g*o+1],Number.isFinite(c)&&Number.isFinite(l)&&(i=l<i?l:i,r=l>r?l:r,a=c<a?c:a,s=c>s?c:s);return{xMin:a,xMax:s,yMin:i,yMax:r}}var Be=class extends O{initializeAggregationLayer({dimensions:e}){super.initializeAggregationLayer(e),this.setState({layerData:{},gpuGridAggregator:new C(this.context.device,{id:`${this.id}-gpu-aggregator`}),cpuGridAggregator:J})}updateState(e){super.updateState(e),this.updateAggregationState(e);let{aggregationDataDirty:t,aggregationWeightsDirty:o,gpuAggregation:i}=this.state;if(this.getNumInstances()<=0)return;let r=!1;(t||i&&o)&&(this._updateAggregation(e),r=!0),!i&&(t||o)&&(this._updateWeightBins(),this._uploadAggregationResults(),r=!0),this.setState({aggregationDirty:r})}finalizeState(e){let{count:t}=this.state.weights;t&&t.aggregationBuffer&&t.aggregationBuffer.delete(),this.state.gpuGridAggregator?.delete(),super.finalizeState(e)}updateShaders(e){this.state.gpuAggregation&&this.state.gpuGridAggregator.updateShaders(e)}updateAggregationState(e){qt.log.assert(!1)}allocateResources(e,t){if(this.state.numRow!==e||this.state.numCol!==t){let o=t*e*4*4,{weights:i}=this.state;for(let r in i){let a=i[r];a.aggregationBuffer&&a.aggregationBuffer.delete(),a.aggregationBuffer=this.context.device.createBuffer({byteLength:o,accessor:{size:4,type:5126,divisor:1}})}}}updateResults({aggregationData:e,maxMinData:t,maxData:o,minData:i}){let{count:r}=this.state.weights;r&&(r.aggregationData=e,r.maxMinData=t,r.maxData=o,r.minData=i)}_updateAggregation(e){let{cpuGridAggregator:t,gpuGridAggregator:o,gridOffset:i,posOffset:r,translation:a=[0,0],scaling:s=[0,0,0],boundingBox:l,projectPoints:c,gpuAggregation:g,numCol:f,numRow:d}=this.state,{props:p}=e,{viewport:x}=this.context,h=this.getAttributes(),y=this.getNumInstances();if(g){let{weights:S}=this.state;o.run({weights:S,cellSize:[i.xOffset,i.yOffset],numCol:f,numRow:d,translation:a,scaling:s,vertexCount:y,projectPoints:c,attributes:h,moduleSettings:this.getModuleSettings()})}else{let S=t(p,{gridOffset:i,projectPoints:c,attributes:h,viewport:x,posOffset:r,boundingBox:l});this.setState({layerData:S})}}_updateWeightBins(){let{getValue:e}=this.state,t=new F(this.state.layerData.data||[],{getValue:e});this.setState({sortedBins:t})}_uploadAggregationResults(){let{numCol:e,numRow:t}=this.state,{data:o}=this.state.layerData,{aggregatedBins:i,minValue:r,maxValue:a,totalCount:s}=this.state.sortedBins,l=4,c=e*t*l,g=new Float32Array(c).fill(0);for(let x of i){let{lonIdx:h,latIdx:y}=o[x.i],{value:S,counts:A}=x,_=(h+y*e)*l;g[_]=S,g[_+l-1]=A}let f=new Float32Array([a,0,0,r]),d=new Float32Array([a,0,0,s]),p=new Float32Array([r,0,0,s]);this.updateResults({aggregationData:g,maxMinData:f,maxData:d,minData:p})}};Be.layerName="GridAggregationLayer";var ee=Be;var or={...Qe.defaultProps,getPosition:{type:"accessor",value:n=>n.position},getWeight:{type:"accessor",value:1},gpuAggregation:!1,aggregation:"SUM"},Yt="positions",ir={data:{props:["cellSizePixels"]},weights:{props:["aggregation"],accessors:["getWeight"]}},xe=class extends ee{initializeState(){super.initializeAggregationLayer({dimensions:ir,getCellSize:o=>o.cellSizePixels});let e={count:{size:1,operation:T.SUM,needMax:!0,maxTexture:$(this.context.device,{id:`${this.id}-max-texture`})}};this.setState({supported:!0,projectPoints:!0,weights:e,subLayerData:{attributes:{}},maxTexture:e.count.maxTexture,positionAttributeName:"positions",posOffset:[0,0],translation:[1,-1]}),this.getAttributeManager().add({[Yt]:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},count:{size:3,accessor:"getWeight"}})}shouldUpdateState({changeFlags:e}){return this.state.supported&&e.somethingChanged}updateState(e){super.updateState(e)}renderLayers(){if(!this.state.supported)return[];let{maxTexture:e,numRow:t,numCol:o,weights:i}=this.state,{updateTriggers:r}=this.props,{aggregationBuffer:a}=i.count,s=this.getSubLayerClass("cells",Qe);return new s(this.props,this.getSubLayerProps({id:"cell-layer",updateTriggers:r}),{data:{attributes:{instanceCounts:a}},maxTexture:e,numInstances:t*o})}finalizeState(e){super.finalizeState(e);let{aggregationBuffer:t,maxBuffer:o,maxTexture:i}=this.state;t?.delete(),o?.delete(),i?.delete()}getPickingInfo({info:e}){let{index:t}=e;if(t>=0){let{gpuGridAggregator:o,gpuAggregation:i,weights:r}=this.state,a=i?o.getData("count"):r.count;e.object=C.getAggregationData({pixelIndex:t,...a})}return e}updateResults({aggregationData:e,maxData:t}){let{count:o}=this.state.weights;o.aggregationData=e,o.aggregationBuffer.write(e),o.maxData=t,o.maxTexture.setImageData({data:t})}updateAggregationState(e){let t=e.props.cellSizePixels,o=e.oldProps.cellSizePixels!==t,{viewportChanged:i}=e.changeFlags,r=e.props.gpuAggregation;this.state.gpuAggregation!==e.props.gpuAggregation&&r&&!C.isSupported(this.context.device)&&($t.log.warn("GPU Grid Aggregation not supported, falling back to CPU")(),r=!1);let a=r!==this.state.gpuAggregation;this.setState({gpuAggregation:r});let s=this.isAttributeChanged(Yt),{dimensions:l}=this.state,{data:c,weights:g}=l,f=s||a||i||this.isAggregationDirty(e,{compareAll:r,dimension:c}),d=this.isAggregationDirty(e,{dimension:g});this.setState({aggregationDataDirty:f,aggregationWeightsDirty:d});let{viewport:p}=this.context;if(i||o){let{width:x,height:h}=p,y=Math.ceil(x/t),S=Math.ceil(h/t);this.allocateResources(S,y),this.setState({scaling:[x/2,-h/2,1],gridOffset:{xOffset:t,yOffset:t},width:x,height:h,numCol:y,numRow:S})}d&&this._updateAccessors(e),(f||d)&&this._resetResults()}_updateAccessors(e){let{getWeight:t,aggregation:o,data:i}=e.props,{count:r}=this.state.weights;r&&(r.getWeight=t,r.operation=T[o]),this.setState({getValue:Y(o,t,{data:i})})}_resetResults(){let{count:e}=this.state.weights;e&&(e.aggregationData=null)}};xe.layerName="ScreenGridLayer";xe.defaultProps=or;var Kt=xe;var to=M(X(),1);function Qt(){}var Zt=["getBins","getDomain","getScaleFunc"],Jt=[{key:"fillColor",accessor:"getFillColor",pickingInfo:"colorValue",getBins:{triggers:{value:{prop:"getColorValue",updateTrigger:"getColorValue"},weight:{prop:"getColorWeight",updateTrigger:"getColorWeight"},aggregation:{prop:"colorAggregation"},filterData:{prop:"_filterData",updateTrigger:"_filterData"}}},getDomain:{triggers:{lowerPercentile:{prop:"lowerPercentile"},upperPercentile:{prop:"upperPercentile"},scaleType:{prop:"colorScaleType"}}},getScaleFunc:{triggers:{domain:{prop:"colorDomain"},range:{prop:"colorRange"}},onSet:{props:"onSetColorDomain"}},nullValue:[0,0,0,0]},{key:"elevation",accessor:"getElevation",pickingInfo:"elevationValue",getBins:{triggers:{value:{prop:"getElevationValue",updateTrigger:"getElevationValue"},weight:{prop:"getElevationWeight",updateTrigger:"getElevationWeight"},aggregation:{prop:"elevationAggregation"},filterData:{prop:"_filterData",updateTrigger:"_filterData"}}},getDomain:{triggers:{lowerPercentile:{prop:"elevationLowerPercentile"},upperPercentile:{prop:"elevationUpperPercentile"},scaleType:{prop:"elevationScaleType"}}},getScaleFunc:{triggers:{domain:{prop:"elevationDomain"},range:{prop:"elevationRange"}},onSet:{props:"onSetElevationDomain"}},nullValue:-1}],rr=n=>n.cellSize,w=class{constructor(e){this.state={layerData:{data:void 0},dimensions:{}},this.changeFlags={},this.dimensionUpdaters={},this._getCellSize=e.getCellSize||rr,this._getAggregator=e.getAggregator,this._addDimension(e.dimensions||Jt)}static defaultDimensions(){return Jt}updateState(e,t){let{oldProps:o,props:i,changeFlags:r}=e;this.updateGetValueFuncs(o,i,r);let a=this.needsReProjectPoints(o,i,r),s=!1;return r.dataChanged||a?(this.getAggregatedData(i,t),s=!0):((this.getDimensionChanges(o,i,r)||[]).forEach(c=>typeof c=="function"&&c()),s=!0),this.setState({aggregationDirty:s}),this.state}setState(e){this.state={...this.state,...e}}setDimensionState(e,t){this.setState({dimensions:{...this.state.dimensions,[e]:{...this.state.dimensions[e],...t}}})}normalizeResult(e={}){return e.hexagons?{data:e.hexagons,...e}:e.layerData?{data:e.layerData,...e}:e}getAggregatedData(e,t){let i=this._getAggregator(e)(e,t);this.setState({layerData:this.normalizeResult(i)}),this.changeFlags={layerData:!0},this.getSortedBins(e)}updateGetValueFuncs(e,t,o){for(let i in this.dimensionUpdaters){let{value:r,weight:a,aggregation:s}=this.dimensionUpdaters[i].getBins.triggers,l=t[r.prop];this.needUpdateDimensionStep(this.dimensionUpdaters[i].getBins,e,t,o)&&(l?l=xt(l,{data:t.data}):l=Y(t[s.prop],t[a.prop],{data:t.data})),l&&this.setDimensionState(i,{getValue:l})}}needsReProjectPoints(e,t,o){return this._getCellSize(e)!==this._getCellSize(t)||this._getAggregator(e)!==this._getAggregator(t)||o.updateTriggersChanged&&(o.updateTriggersChanged.all||o.updateTriggersChanged.getPosition)}addDimension(e){this._addDimension(e)}_addDimension(e=[]){e.forEach(t=>{let{key:o}=t;this.dimensionUpdaters[o]=this.getDimensionUpdaters(t),this.state.dimensions[o]={getValue:null,domain:null,sortedBins:null,scaleFunc:Qt}})}getDimensionUpdaters({key:e,accessor:t,pickingInfo:o,getBins:i,getDomain:r,getScaleFunc:a,nullValue:s}){return{key:e,accessor:t,pickingInfo:o,getBins:{updater:this.getDimensionSortedBins.bind(this),...i},getDomain:{updater:this.getDimensionValueDomain.bind(this),...r},getScaleFunc:{updater:this.getDimensionScale.bind(this),...a},attributeAccessor:this.getSubLayerDimensionAttribute(e,s)}}needUpdateDimensionStep(e,t,o,i){return Object.values(e.triggers).some(r=>r.updateTrigger?i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged[r.updateTrigger]):t[r.prop]!==o[r.prop])}getDimensionChanges(e,t,o){let i=[];for(let r in this.dimensionUpdaters){let a=Zt.find(s=>this.needUpdateDimensionStep(this.dimensionUpdaters[r][s],e,t,o));a&&i.push(this.dimensionUpdaters[r][a].updater.bind(this,t,this.dimensionUpdaters[r]))}return i.length?i:null}getUpdateTriggers(e){let t=e.updateTriggers||{},o={};for(let i in this.dimensionUpdaters){let{accessor:r}=this.dimensionUpdaters[i];o[r]={},Zt.forEach(a=>{Object.values(this.dimensionUpdaters[i][a].triggers).forEach(({prop:s,updateTrigger:l})=>{if(l){let c=t[l];typeof c=="object"&&!Array.isArray(c)?Object.assign(o[r],c):c!==void 0&&(o[r][s]=c)}else o[r][s]=e[s]})})}return o}getSortedBins(e){for(let t in this.dimensionUpdaters)this.getDimensionSortedBins(e,this.dimensionUpdaters[t])}getDimensionSortedBins(e,t){let{key:o}=t,{getValue:i}=this.state.dimensions[o],r=new F(this.state.layerData.data||[],{getValue:i,filterData:e._filterData});this.setDimensionState(o,{sortedBins:r}),this.getDimensionValueDomain(e,t)}getDimensionValueDomain(e,t){let{getDomain:o,key:i}=t,{triggers:{lowerPercentile:r,upperPercentile:a,scaleType:s}}=o,l=this.state.dimensions[i].sortedBins.getValueDomainByScale(e[s.prop],[e[r.prop],e[a.prop]]);this.setDimensionState(i,{valueDomain:l}),this.getDimensionScale(e,t)}getDimensionScale(e,t){let{key:o,getScaleFunc:i,getDomain:r}=t,{domain:a,range:s}=i.triggers,{scaleType:l}=r.triggers,{onSet:c}=i,g=e[s.prop],f=e[a.prop]||this.state.dimensions[o].valueDomain,p=Gt(l&&e[l.prop])(f,g);typeof c=="object"&&typeof e[c.props]=="function"&&e[c.props](p.domain()),this.setDimensionState(o,{scaleFunc:p})}getSubLayerDimensionAttribute(e,t){return o=>{let{sortedBins:i,scaleFunc:r}=this.state.dimensions[e],a=i.binMap[o.index];if(a&&a.counts===0)return t;let s=a&&a.value,l=r.domain();return s>=l[0]&&s<=l[l.length-1]?r(s):t}}getSubLayerAccessors(e){let t={};for(let o in this.dimensionUpdaters){let{accessor:i}=this.dimensionUpdaters[o];t[i]=this.getSubLayerDimensionAttribute(e,o)}return t}getPickingInfo({info:e}){let t=e.picked&&e.index>-1,o=null;if(t){let i=this.state.layerData.data[e.index],r={};for(let a in this.dimensionUpdaters){let{pickingInfo:s}=this.dimensionUpdaters[a],{sortedBins:l}=this.state.dimensions[a],c=l.binMap[i.index]&&l.binMap[i.index].value;r[s]=c}o=Object.assign(r,i,{points:i.filteredPoints||i.points})}return e.picked=Boolean(o),e.object=o,e}getAccessor(e){return this.dimensionUpdaters.hasOwnProperty(e)?this.dimensionUpdaters[e].attributeAccessor:Qt}};function eo(){}var nr={colorDomain:null,colorRange:N,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",min:0,max:100,value:0},upperPercentile:{type:"number",min:0,max:100,value:100},colorScaleType:"quantize",onSetColorDomain:eo,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationLowerPercentile:{type:"number",min:0,max:100,value:0},elevationUpperPercentile:{type:"number",min:0,max:100,value:100},elevationScale:{type:"number",min:0,value:1},elevationScaleType:"linear",onSetElevationDomain:eo,gridAggregator:J,cellSize:{type:"number",min:0,max:1e3,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:n=>n.position},extruded:!1,material:!0,_filterData:{type:"function",value:null,optional:!0}},ve=class extends O{initializeState(){let e=new w({getAggregator:o=>o.gridAggregator,getCellSize:o=>o.cellSize});this.state={cpuAggregator:e,aggregatorState:e.state},this.getAttributeManager().add({positions:{size:3,type:"float64",accessor:"getPosition"}})}updateState(e){super.updateState(e),this.setState({aggregatorState:this.state.cpuAggregator.updateState(e,{viewport:this.context.viewport,attributes:this.getAttributes(),numInstances:this.getNumInstances()})})}getPickingInfo({info:e}){return this.state.cpuAggregator.getPickingInfo({info:e})}_onGetSublayerColor(e){return this.state.cpuAggregator.getAccessor("fillColor")(e)}_onGetSublayerElevation(e){return this.state.cpuAggregator.getAccessor("elevation")(e)}_getSublayerUpdateTriggers(){return this.state.cpuAggregator.getUpdateTriggers(this.props)}renderLayers(){let{elevationScale:e,extruded:t,cellSize:o,coverage:i,material:r,transitions:a}=this.props,{cpuAggregator:s}=this.state,l=this.getSubLayerClass("grid-cell",to.GridCellLayer),c=this._getSublayerUpdateTriggers();return new l({cellSize:o,coverage:i,material:r,elevationScale:e,extruded:t,getFillColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:a&&{getFillColor:a.getColorValue||a.getColorWeight,getElevation:a.getElevationValue||a.getElevationWeight}},this.getSubLayerProps({id:"grid-cell",updateTriggers:c}),{data:s.state.layerData.data})}};ve.layerName="CPUGridLayer";ve.defaultProps=nr;var Se=ve;var ro=M(E(),1),no=M(X(),1);var te=Math.PI/3,ar=[0,te,2*te,3*te,4*te,5*te];function sr(n){return n[0]}function lr(n){return n[1]}function Je(){var n=0,e=0,t=1,o=1,i=sr,r=lr,a,s,l;function c(f){var d={},p=[],x,h=f.length;for(x=0;x<h;++x)if(!(isNaN(S=+i.call(null,y=f[x],x,f))||isNaN(A=+r.call(null,y,x,f)))){var y,S,A,_=Math.round(A=A/l),b=Math.round(S=S/s-(_&1)/2),D=A-_;if(Math.abs(D)*3>1){var R=S-b,fe=b+(S<b?-1:1)/2,z=_+(A<_?-1:1),H=S-fe,V=A-z;R*R+D*D>H*H+V*V&&(b=fe+(_&1?1:-1)/2,_=z)}var lt=b+"-"+_,de=d[lt];de?de.push(y):(p.push(de=d[lt]=[y]),de.x=(b+(_&1)/2)*s,de.y=_*l)}return p}function g(f){var d=0,p=0;return ar.map(function(x){var h=Math.sin(x)*f,y=-Math.cos(x)*f,S=h-d,A=y-p;return d=h,p=y,[S,A]})}return c.hexagon=function(f){return"m"+g(f==null?a:+f).join("l")+"z"},c.centers=function(){for(var f=[],d=Math.round(e/l),p=Math.round(n/s),x=d*l;x<o+a;x+=l,++d)for(var h=p*s+(d&1)*s/2;h<t+s/2;h+=s)f.push([h,x]);return f},c.mesh=function(){var f=g(a).slice(0,4).join("l");return c.centers().map(function(d){return"M"+d+"m"+f}).join("")},c.x=function(f){return arguments.length?(i=f,c):i},c.y=function(f){return arguments.length?(r=f,c):r},c.radius=function(f){return arguments.length?(a=+f,s=a*2*Math.sin(te),l=a*1.5,c):a},c.size=function(f){return arguments.length?(n=e=0,t=+f[0],o=+f[1],c):[t-n,o-e]},c.extent=function(f){return arguments.length?(n=+f[0][0],e=+f[0][1],t=+f[1][0],o=+f[1][1],c):[[n,e],[t,o]]},c.radius(1)}var Ue=M(E(),1);function oo(n,e){let{data:t,radius:o}=n,{viewport:i,attributes:r}=e,a=t.length?cr(t,e):null,s=ur(o,i,a),l=[],{iterable:c,objectInfo:g}=(0,Ue.createIterable)(t),f=r.positions.value,{size:d}=r.positions.getAccessor();for(let h of c){g.index++;let y=g.index*d,S=[f[y],f[y+1]];Number.isFinite(S[0])&&Number.isFinite(S[1])?l.push({screenCoord:i.projectFlat(S),source:h,index:g.index}):Ue.log.warn("HexagonLayer: invalid position")()}return{hexagons:Je().radius(s).x(h=>h.screenCoord[0]).y(h=>h.screenCoord[1])(l).map((h,y)=>({position:i.unprojectFlat([h.x,h.y]),points:h,index:y})),radiusCommon:s}}function cr(n,e){let{attributes:t}=e,o=t.positions.value,{size:i}=t.positions.getAccessor(),r=1/0,a=1/0,s=-1/0,l=-1/0,c;for(c=0;c<i*n.length;c+=i){let g=o[c],f=o[c+1];Number.isFinite(g)&&Number.isFinite(f)&&(r=Math.min(g,r),s=Math.max(g,s),a=Math.min(f,a),l=Math.max(f,l))}return[r,a,s,l].every(Number.isFinite)?[(r+s)/2,(a+l)/2]:null}function ur(n,e,t){let{unitsPerMeter:o}=e.getDistanceScales(t);return n*o[0]}function io(){}var gr={colorDomain:null,colorRange:N,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",value:0,min:0,max:100},upperPercentile:{type:"number",value:100,min:0,max:100},colorScaleType:"quantize",onSetColorDomain:io,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationLowerPercentile:{type:"number",value:0,min:0,max:100},elevationUpperPercentile:{type:"number",value:100,min:0,max:100},elevationScale:{type:"number",min:0,value:1},elevationScaleType:"linear",onSetElevationDomain:io,radius:{type:"number",value:1e3,min:1},coverage:{type:"number",min:0,max:1,value:1},extruded:!1,hexagonAggregator:oo,getPosition:{type:"accessor",value:n=>n.position},material:!0,_filterData:{type:"function",value:null,optional:!0}},ye=class extends O{initializeState(){let e=new w({getAggregator:o=>o.hexagonAggregator,getCellSize:o=>o.radius});this.state={cpuAggregator:e,aggregatorState:e.state,vertices:null},this.getAttributeManager().add({positions:{size:3,type:"float64",accessor:"getPosition"}})}updateState(e){if(super.updateState(e),e.changeFlags.propsOrDataChanged){let t=this.state.cpuAggregator.updateState(e,{viewport:this.context.viewport,attributes:this.getAttributes()});if(this.state.aggregatorState.layerData!==t.layerData){let{hexagonVertices:o}=t.layerData||{};this.setState({vertices:o&&this.convertLatLngToMeterOffset(o)})}this.setState({aggregatorState:t})}}convertLatLngToMeterOffset(e){let{viewport:t}=this.context;if(Array.isArray(e)&&e.length===6){let o=e[0],i=e[3],r=[(o[0]+i[0])/2,(o[1]+i[1])/2],a=t.projectFlat(r),{metersPerUnit:s}=t.getDistanceScales(r);return e.map(c=>{let g=t.projectFlat(c);return[(g[0]-a[0])*s[0],(g[1]-a[1])*s[1]]})}return ro.log.error("HexagonLayer: hexagonVertices needs to be an array of 6 points")(),null}getPickingInfo({info:e}){return this.state.cpuAggregator.getPickingInfo({info:e})}_onGetSublayerColor(e){return this.state.cpuAggregator.getAccessor("fillColor")(e)}_onGetSublayerElevation(e){return this.state.cpuAggregator.getAccessor("elevation")(e)}_getSublayerUpdateTriggers(){return this.state.cpuAggregator.getUpdateTriggers(this.props)}renderLayers(){let{elevationScale:e,extruded:t,coverage:o,material:i,transitions:r}=this.props,{aggregatorState:a,vertices:s}=this.state,l=this.getSubLayerClass("hexagon-cell",no.ColumnLayer),c=this._getSublayerUpdateTriggers(),g=s?{vertices:s,radius:1}:{radius:a.layerData.radiusCommon||1,radiusUnits:"common",angle:90};return new l({...g,diskResolution:6,elevationScale:e,extruded:t,coverage:o,material:i,getFillColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:r&&{getFillColor:r.getColorValue||r.getColorWeight,getElevation:r.getElevationValue||r.getElevationWeight}},this.getSubLayerProps({id:"hexagon-cell",updateTriggers:c}),{data:a.layerData.data})}};ye.layerName="HexagonLayer";ye.defaultProps=gr;var ao=ye;var Ve=M(X(),1);var Fo=M(E(),1);var v=.16666666666666666,u={N:[0,.5],E:[.5,0],S:[0,-.5],W:[-.5,0],NE:[.5,.5],NW:[-.5,.5],SE:[.5,-.5],SW:[-.5,-.5]},oe=[u.W,u.SW,u.S],ie=[u.S,u.SE,u.E],re=[u.E,u.NE,u.N],ne=[u.NW,u.W,u.N],ae=[[-.5,v],[-.5,-v],[-v,-.5],[v,-.5]],se=[[-v,-.5],[v,-.5],[.5,-v],[.5,v]],le=[[.5,-v],[.5,v],[v,.5],[-v,.5]],ce=[[-.5,v],[-.5,-v],[v,.5],[-v,.5]],so=[u.W,u.SW,u.SE,u.E],lo=[u.S,u.SE,u.NE,u.N],co=[u.NW,u.W,u.E,u.NE],uo=[u.NW,u.SW,u.S,u.N],go=[[-.5,v],[-.5,-v],[.5,-v],[.5,v]],fo=[[-v,-.5],[v,-.5],[v,.5],[-v,.5]],fr=[u.NW,u.SW,u.SE,u.NE],po=[u.NW,u.SW,u.SE,u.E,u.N],mo=[u.W,u.SW,u.SE,u.NE,u.N],ho=[u.NW,u.W,u.S,u.SE,u.NE],xo=[u.NW,u.SW,u.S,u.E,u.NE],vo=[u.NW,u.W,[.5,-v],[.5,v],u.N],So=[[-v,-.5],[v,-.5],u.E,u.NE,u.N],yo=[[-.5,v],[-.5,-v],u.S,u.SE,u.E],Ao=[u.W,u.SW,u.S,[v,.5],[-v,.5]],_o=[u.NW,u.W,[-v,-.5],[v,-.5],u.N],bo=[[-.5,v],[-.5,-v],u.E,u.NE,u.N],Mo=[u.S,u.SE,u.E,[v,.5],[-v,.5]],To=[u.W,u.SW,u.S,[.5,-v],[.5,v]],Co=[u.W,u.SW,u.SE,u.E,[v,.5],[-v,.5]],Eo=[[-.5,v],[-.5,-v],u.S,u.SE,u.NE,u.N],Po=[u.NW,u.W,[-v,-.5],[v,-.5],u.E,u.NE],No=[u.NW,u.SW,u.S,[.5,-v],[.5,v],u.N],ue=[u.W,u.SW,u.S,u.E,u.NE,u.N],ge=[u.NW,u.W,u.S,u.SE,u.E,u.N],Ge=[[-.5,v],[-.5,-v],[-v,-.5],[v,-.5],u.E,u.NE,u.N],We=[u.W,u.SW,u.S,[.5,-v],[.5,v],[v,.5],[-v,.5]],ze=[u.NW,u.W,[-v,-.5],[v,-.5],[.5,-v],[.5,v],u.N],He=[[-.5,v],[-.5,-v],u.S,u.SE,u.E,[v,.5],[-v,.5]],Do=[[-.5,v],[-.5,-v],[-v,-.5],[v,-.5],[.5,-v],[.5,v],[v,.5],[-v,.5]],Lo={0:[],1:[[u.W,u.S]],2:[[u.S,u.E]],3:[[u.W,u.E]],4:[[u.N,u.E]],5:{0:[[u.W,u.S],[u.N,u.E]],1:[[u.W,u.N],[u.S,u.E]]},6:[[u.N,u.S]],7:[[u.W,u.N]],8:[[u.W,u.N]],9:[[u.N,u.S]],10:{0:[[u.W,u.N],[u.S,u.E]],1:[[u.W,u.S],[u.N,u.E]]},11:[[u.N,u.E]],12:[[u.W,u.E]],13:[[u.S,u.E]],14:[[u.W,u.S]],15:[]};function m(n){return parseInt(n,4)}var Oo={[m("0000")]:[],[m("2222")]:[],[m("2221")]:[oe],[m("2212")]:[ie],[m("2122")]:[re],[m("1222")]:[ne],[m("0001")]:[oe],[m("0010")]:[ie],[m("0100")]:[re],[m("1000")]:[ne],[m("2220")]:[ae],[m("2202")]:[se],[m("2022")]:[le],[m("0222")]:[ce],[m("0002")]:[ae],[m("0020")]:[se],[m("0200")]:[le],[m("2000")]:[ce],[m("0011")]:[so],[m("0110")]:[lo],[m("1100")]:[co],[m("1001")]:[uo],[m("2211")]:[so],[m("2112")]:[lo],[m("1122")]:[co],[m("1221")]:[uo],[m("2200")]:[go],[m("2002")]:[fo],[m("0022")]:[go],[m("0220")]:[fo],[m("1111")]:[fr],[m("1211")]:[po],[m("2111")]:[mo],[m("1112")]:[ho],[m("1121")]:[xo],[m("1011")]:[po],[m("0111")]:[mo],[m("1110")]:[ho],[m("1101")]:[xo],[m("1200")]:[vo],[m("0120")]:[So],[m("0012")]:[yo],[m("2001")]:[Ao],[m("1022")]:[vo],[m("2102")]:[So],[m("2210")]:[yo],[m("0221")]:[Ao],[m("1002")]:[_o],[m("2100")]:[bo],[m("0210")]:[Mo],[m("0021")]:[To],[m("1220")]:[_o],[m("0122")]:[bo],[m("2012")]:[Mo],[m("2201")]:[To],[m("0211")]:[Co],[m("2110")]:[Eo],[m("1102")]:[Po],[m("1021")]:[No],[m("2011")]:[Co],[m("0112")]:[Eo],[m("1120")]:[Po],[m("1201")]:[No],[m("2101")]:[ue],[m("0121")]:[ue],[m("1012")]:[ge],[m("1210")]:[ge],[m("0101")]:{0:[oe,re],1:[ue],2:[ue]},[m("1010")]:{0:[ne,ie],1:[ge],2:[ge]},[m("2121")]:{0:[ue],1:[ue],2:[oe,re]},[m("1212")]:{0:[ge],1:[ge],2:[ne,ie]},[m("2120")]:{0:[Ge],1:[Ge],2:[ae,re]},[m("2021")]:{0:[We],1:[We],2:[oe,le]},[m("1202")]:{0:[ze],1:[ze],2:[ne,se]},[m("0212")]:{0:[He],1:[He],2:[ie,ce]},[m("0102")]:{0:[ae,re],1:[Ge],2:[Ge]},[m("0201")]:{0:[oe,le],1:[We],2:[We]},[m("1020")]:{0:[ne,se],1:[ze],2:[ze]},[m("2010")]:{0:[ie,ce],1:[He],2:[He]},[m("2020")]:{0:[ce,se],1:[Do],2:[ae,le]},[m("0202")]:{0:[le,ae],1:[Do],2:[ce,se]}};var j={ISO_LINES:1,ISO_BANDS:2},dr={zIndex:0,zOffset:.005};function Ae(n,e){return Array.isArray(e)?n<e[0]?0:n<e[1]?1:2:n>=e?1:0}function wo(n){let{cellWeights:e,x:t,y:o,width:i,height:r}=n,a=n.threshold;n.thresholdValue&&(Fo.log.deprecated("thresholdValue","threshold")(),a=n.thresholdValue);let s=t<0,l=t>=i-1,c=o<0,g=o>=r-1,f=s||l||c||g,d={},p={};s||g?p.top=0:(d.top=e[(o+1)*i+t],p.top=Ae(d.top,a)),l||g?p.topRight=0:(d.topRight=e[(o+1)*i+t+1],p.topRight=Ae(d.topRight,a)),l||c?p.right=0:(d.right=e[o*i+t+1],p.right=Ae(d.right,a)),s||c?p.current=0:(d.current=e[o*i+t],p.current=Ae(d.current,a));let{top:x,topRight:h,right:y,current:S}=p,A=-1;Number.isFinite(a)&&(A=x<<3|h<<2|y<<1|S),Array.isArray(a)&&(A=x<<6|h<<4|y<<2|S);let _=0;return f||(_=Ae((d.top+d.topRight+d.right+d.current)/4,a)),{code:A,meanCode:_}}function et(n){let{gridOrigin:e,cellSize:t,x:o,y:i,code:r,meanCode:a,type:s=j.ISO_LINES}=n,l={...dr,...n.thresholdData},c=s===j.ISO_BANDS?Oo[r]:Lo[r];Array.isArray(c)||(c=c[a]);let g=l.zIndex*l.zOffset,f=(o+1)*t[0],d=(i+1)*t[1],p=e[0]+f,x=e[1]+d;if(s===j.ISO_BANDS){let y=[];return c.forEach(S=>{let A=[];S.forEach(_=>{let b=p+_[0]*t[0],D=x+_[1]*t[1];A.push([b,D,g])}),y.push(A)}),y}let h=[];return c.forEach(y=>{y.forEach(S=>{let A=p+S[0]*t[0],_=x+S[1]*t[1];h.push([A,_,g])})}),h}function Io({thresholdData:n,cellWeights:e,gridSize:t,gridOrigin:o,cellSize:i}){let r=[],a=[],s=t[0],l=t[1],c=0,g=0;for(let f of n){let{contour:d}=f,{threshold:p}=d;for(let x=-1;x<s;x++)for(let h=-1;h<l;h++){let{code:y,meanCode:S}=wo({cellWeights:e,threshold:p,x,y:h,width:s,height:l}),A={type:j.ISO_BANDS,gridOrigin:o,cellSize:i,x,y:h,width:s,height:l,code:y,meanCode:S,thresholdData:f};if(Array.isArray(p)){A.type=j.ISO_BANDS;let _=et(A);for(let b of _)a[g++]={vertices:b,contour:d}}else{A.type=j.ISO_LINES;let _=et(A);for(let b=0;b<_.length;b+=2)r[c++]={start:_[b],end:_[b+1],contour:d}}}}return{contourSegments:r,contourPolygons:a}}var Uo=M(E(),1);var Ro=[255,255,255,255],pr=1,mr=1,hr={cellSize:{type:"number",min:1,max:1e3,value:1e3},getPosition:{type:"accessor",value:n=>n.position},getWeight:{type:"accessor",value:1},gpuAggregation:!1,aggregation:"SUM",contours:{type:"object",value:[{threshold:mr}],optional:!0,compare:3},zOffset:.005},Bo="positions",xr={data:{props:["cellSize"]},weights:{props:["aggregation"],accessors:["getWeight"]}},_e=class extends ee{initializeState(){super.initializeAggregationLayer({dimensions:xr}),this.setState({contourData:{},projectPoints:!1,weights:{count:{size:1,operation:T.SUM}}}),this.getAttributeManager().add({[Bo]:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},count:{size:3,accessor:"getWeight"}})}updateState(e){super.updateState(e);let t=!1,{oldProps:o,props:i}=e,{aggregationDirty:r}=this.state;(o.contours!==i.contours||o.zOffset!==i.zOffset)&&(t=!0,this._updateThresholdData(e.props)),this.getNumInstances()>0&&(r||t)&&this._generateContours()}renderLayers(){let{contourSegments:e,contourPolygons:t}=this.state.contourData,o=this.getSubLayerClass("lines",Ve.LineLayer),i=this.getSubLayerClass("bands",Ve.SolidPolygonLayer),r=e&&e.length>0&&new o(this.getSubLayerProps({id:"lines"}),{data:this.state.contourData.contourSegments,getSourcePosition:s=>s.start,getTargetPosition:s=>s.end,getColor:s=>s.contour.color||Ro,getWidth:s=>s.contour.strokeWidth||pr}),a=t&&t.length>0&&new i(this.getSubLayerProps({id:"bands"}),{data:this.state.contourData.contourPolygons,getPolygon:s=>s.vertices,getFillColor:s=>s.contour.color||Ro});return[r,a]}updateAggregationState(e){let{props:t,oldProps:o}=e,{cellSize:i,coordinateSystem:r}=t,{viewport:a}=this.context,s=o.cellSize!==i,l=t.gpuAggregation;this.state.gpuAggregation!==t.gpuAggregation&&l&&!C.isSupported(this.context.device)&&(Uo.log.warn("GPU Grid Aggregation not supported, falling back to CPU")(),l=!1);let c=l!==this.state.gpuAggregation;this.setState({gpuAggregation:l});let{dimensions:g}=this.state,f=this.isAttributeChanged(Bo),{data:d,weights:p}=g,{boundingBox:x}=this.state;if(f&&(x=Ie(this.getAttributes(),this.getNumInstances()),this.setState({boundingBox:x})),f||s){let{gridOffset:S,translation:A,width:_,height:b,numCol:D,numRow:R}=Re(x,i,a,r);this.allocateResources(R,D),this.setState({gridOffset:S,boundingBox:x,translation:A,posOffset:A.slice(),gridOrigin:[-1*A[0],-1*A[1]],width:_,height:b,numCol:D,numRow:R})}let h=f||c||this.isAggregationDirty(e,{dimension:d,compareAll:l}),y=this.isAggregationDirty(e,{dimension:p});y&&this._updateAccessors(e),(h||y)&&this._resetResults(),this.setState({aggregationDataDirty:h,aggregationWeightsDirty:y})}_updateAccessors(e){let{getWeight:t,aggregation:o,data:i}=e.props,{count:r}=this.state.weights;r&&(r.getWeight=t,r.operation=T[o]),this.setState({getValue:Y(o,t,{data:i})})}_resetResults(){let{count:e}=this.state.weights;e&&(e.aggregationData=null)}_generateContours(){let{numCol:e,numRow:t,gridOrigin:o,gridOffset:i,thresholdData:r}=this.state,{count:a}=this.state.weights,{aggregationData:s}=a;s||(s=a.aggregationBuffer.readSyncWebGL(),a.aggregationData=s);let{cellWeights:l}=C.getCellData({countsData:s}),c=Io({thresholdData:r,cellWeights:l,gridSize:[e,t],gridOrigin:o,cellSize:[i.xOffset,i.yOffset]});this.setState({contourData:c})}_updateThresholdData(e){let{contours:t,zOffset:o}=e,i=t.length,r=new Array(i);for(let a=0;a<i;a++){let s=t[a];r[a]={contour:s,zIndex:s.zIndex||a,zOffset:o}}this.setState({thresholdData:r})}};_e.layerName="ContourLayer";_e.defaultProps=hr;var Go=_e;var qo=M(E(),1);var Xo=M(E(),1);var P=M(E(),1),Ho=M(k(),1);var Vo=M(k(),1);var Wo=`#version 300 es
#define SHADER_NAME gpu-grid-cell-layer-vertex-shader
#define RANGE_COUNT 6
in vec3 positions;
in vec3 normals;
in vec4 colors;
in vec4 elevations;
in vec3 instancePickingColors;
uniform vec2 offset;
uniform bool extruded;
uniform float cellSize;
uniform float coverage;
uniform float opacity;
uniform float elevationScale;
uniform ivec2 gridSize;
uniform vec2 gridOrigin;
uniform vec2 gridOriginLow;
uniform vec2 gridOffset;
uniform vec2 gridOffsetLow;
uniform vec4 colorRange[RANGE_COUNT];
uniform vec2 elevationRange;
uniform vec2 colorDomain;
uniform bool colorDomainValid;
uniform vec2 elevationDomain;
uniform bool elevationDomainValid;
layout(std140) uniform;
uniform ColorData
{
vec4 maxMinCount;
} colorData;
uniform ElevationData
{
vec4 maxMinCount;
} elevationData;
#define EPSILON 0.00001
out vec4 vColor;
vec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {
vec4 outColor = vec4(0., 0., 0., 0.);
if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {
float domainRange = domain.y - domain.x;
if (domainRange <= 0.) {
outColor = colorRange[0];
} else {
float rangeCount = float(RANGE_COUNT);
float rangeStep = domainRange / rangeCount;
float idx = floor((value - domain.x) / rangeStep);
idx = clamp(idx, 0., rangeCount - 1.);
int intIdx = int(idx);
outColor = colorRange[intIdx];
}
}
return outColor;
}
float linearScale(vec2 domain, vec2 range, float value) {
if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {
return ((value - domain.x) / (domain.y - domain.x)) * (range.y - range.x) + range.x;
}
return -1.;
}
void main(void) {
vec2 clrDomain = colorDomainValid ? colorDomain : vec2(colorData.maxMinCount.a, colorData.maxMinCount.r);
vec4 color = quantizeScale(clrDomain, colorRange, colors.r);
float elevation = 0.0;
if (extruded) {
vec2 elvDomain = elevationDomainValid ? elevationDomain : vec2(elevationData.maxMinCount.a, elevationData.maxMinCount.r);
elevation = linearScale(elvDomain, elevationRange, elevations.r);
elevation = elevation  * (positions.z + 1.0) / 2.0 * elevationScale;
}
float shouldRender = float(color.r > 0.0 && elevations.r >= 0.0);
float dotRadius = cellSize / 2. * coverage * shouldRender;
int yIndex = (gl_InstanceID / gridSize[0]);
int xIndex = gl_InstanceID - (yIndex * gridSize[0]);
vec2 instancePositionXFP64 = mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(float(xIndex), 0.));
instancePositionXFP64 = sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));
vec2 instancePositionYFP64 = mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(float(yIndex), 0.));
instancePositionYFP64 = sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));
vec3 centroidPosition = vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);
vec3 centroidPosition64Low = vec3(instancePositionXFP64[1], instancePositionYFP64[1], 0.0);
geometry.worldPosition = centroidPosition;
vec3 pos = vec3(project_size(positions.xy + offset) * dotRadius, 0.);
picking_setPickingColor(instancePickingColors);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
vec3 normals_commonspace = project_normal(normals);
if (extruded) {
vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, normals_commonspace);
vColor = vec4(lightColor, color.a * opacity) / 255.;
} else {
vColor = vec4(color.rgb, color.a * opacity) / 255.;
}
}
`;var zo=`#version 300 es
#define SHADER_NAME gpu-grid-cell-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
fragColor = picking_filterColor(fragColor);
}
`;var tt=0,ot=1,vr={colorDomain:null,colorRange:N,elevationDomain:null,elevationRange:[0,1e3],elevationScale:{type:"number",min:0,value:1},gridSize:{type:"array",value:[1,1]},gridOrigin:{type:"array",value:[0,0]},gridOffset:{type:"array",value:[0,0]},cellSize:{type:"number",min:0,max:1e3,value:1e3},offset:{type:"array",value:[1,1]},coverage:{type:"number",min:0,max:1,value:1},extruded:!0,material:!0},be=class extends P.Layer{getShaders(){return super.getShaders({vs:Wo,fs:zo,modules:[P.project32,P.gouraudLighting,P.picking,q]})}initializeState(){this.getAttributeManager().addInstanced({colors:{size:4,noAlloc:!0},elevations:{size:4,noAlloc:!0}});let t=this._getModel();this._setupUniformBuffer(t),this.setState({model:t})}_getModel(){return new Vo.Model(this.context.device,{...this.getShaders(),id:this.props.id,geometry:new Ho.CubeGeometry,isInstanced:!0})}draw({uniforms:e}){let{cellSize:t,offset:o,extruded:i,elevationScale:r,coverage:a,gridSize:s,gridOrigin:l,gridOffset:c,elevationRange:g,colorMaxMinBuffer:f,elevationMaxMinBuffer:d}=this.props,p=this.state.model,x=[(0,P.fp64LowPart)(l[0]),(0,P.fp64LowPart)(l[1])],h=[(0,P.fp64LowPart)(c[0]),(0,P.fp64LowPart)(c[1])],y=this.getDomainUniforms(),S=G(this.props.colorRange);this.bindUniformBuffers(f,d),p.setUniforms(e),p.setUniforms(y),p.setUniforms({cellSize:t,offset:o,extruded:i,elevationScale:r,coverage:a,gridSize:s,gridOrigin:l,gridOriginLow:x,gridOffset:c,gridOffsetLow:h,colorRange:S,elevationRange:g}),p.draw(this.context.renderPass),this.unbindUniformBuffers(f,d)}bindUniformBuffers(e,t){e.bind({target:35345,index:tt}),t.bind({target:35345,index:ot})}unbindUniformBuffers(e,t){e.unbind({target:35345,index:tt}),t.unbind({target:35345,index:ot})}getDomainUniforms(){let{colorDomain:e,elevationDomain:t}=this.props,o={};return e!==null?(o.colorDomainValid=!0,o.colorDomain=e):o.colorDomainValid=!1,t!==null?(o.elevationDomainValid=!0,o.elevationDomain=t):o.elevationDomainValid=!1,o}_setupUniformBuffer(e){let t=e.pipeline.handle,o=this.context.gl,i=o.getUniformBlockIndex(t,"ColorData"),r=o.getUniformBlockIndex(t,"ElevationData");o.uniformBlockBinding(t,i,tt),o.uniformBlockBinding(t,r,ot)}};be.layerName="GPUGridCellLayer";be.defaultProps=vr;var ko=be;var Sr={colorDomain:null,colorRange:N,getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",elevationDomain:null,elevationRange:[0,1e3],getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationScale:{type:"number",min:0,value:1},cellSize:{type:"number",min:1,max:1e3,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:n=>n.position},extruded:!1,material:!0},yr={data:{props:["cellSize","colorAggregation","elevationAggregation"]}},jo="positions",Me=class extends ee{initializeState({device:e}){let t=C.isSupported(e);t||Xo.log.error("GPUGridLayer is not supported on this browser, use GridLayer instead")(),super.initializeAggregationLayer({dimensions:yr}),this.setState({gpuAggregation:!1,projectPoints:!1,isSupported:t,weights:{color:{needMin:!0,needMax:!0,combineMaxMin:!0,maxMinBuffer:e.createBuffer({byteLength:4*4,accessor:{size:4,type:5126,divisor:1}})},elevation:{needMin:!0,needMax:!0,combineMaxMin:!0,maxMinBuffer:e.createBuffer({byteLength:4*4,accessor:{size:4,type:5126,divisor:1}})}},positionAttributeName:"positions"}),this.getAttributeManager().add({[jo]:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},color:{size:3,accessor:"getColorWeight"},elevation:{size:3,accessor:"getElevationWeight"}})}updateState(e){if(this.state.isSupported===!1)return;super.updateState(e);let{aggregationDirty:t}=this.state;t&&this.setState({gridHash:null})}getHashKeyForIndex(e){let{numRow:t,numCol:o,boundingBox:i,gridOffset:r}=this.state,a=[o,t],s=[i.xMin,i.yMin],l=[r.xOffset,r.yOffset],c=Math.floor(e/a[0]),g=e-c*a[0],f=Math.floor((c*l[1]+s[1]+90+l[1]/2)/l[1]),d=Math.floor((g*l[0]+s[0]+180+l[0]/2)/l[0]);return`${f}-${d}`}getPositionForIndex(e){let{numRow:t,numCol:o,boundingBox:i,gridOffset:r}=this.state,a=[o,t],s=[i.xMin,i.yMin],l=[r.xOffset,r.yOffset],c=Math.floor(e/a[0]),g=e-c*a[0],f=c*l[1]+s[1];return[g*l[0]+s[0],f]}getPickingInfo({info:e,mode:t}){let{index:o}=e,i=null;if(o>=0){let r=this.state.gpuGridAggregator,a=this.getPositionForIndex(o),s=C.getAggregationData({pixelIndex:o,...r.getData("color")}),l=C.getAggregationData({pixelIndex:o,...r.getData("elevation")});if(i={colorValue:s.cellWeight,elevationValue:l.cellWeight,count:s.cellCount||l.cellCount,position:a,totalCount:s.totalCount||l.totalCount},t!=="hover"){let{props:c}=this,{gridHash:g}=this.state;if(!g){let{gridOffset:p,translation:x,boundingBox:h}=this.state,{viewport:y}=this.context,S=this.getAttributes();g=J(c,{gridOffset:p,attributes:S,viewport:y,translation:x,boundingBox:h}).gridHash,this.setState({gridHash:g})}let f=this.getHashKeyForIndex(o),d=g[f];Object.assign(i,d)}}return e.picked=Boolean(i),e.object=i,e}renderLayers(){if(!this.state.isSupported)return null;let{elevationScale:e,extruded:t,cellSize:o,coverage:i,material:r,elevationRange:a,colorDomain:s,elevationDomain:l}=this.props,{weights:c,numRow:g,numCol:f,gridOrigin:d,gridOffset:p}=this.state,{color:x,elevation:h}=c,y=G(this.props.colorRange),S=this.getSubLayerClass("gpu-grid-cell",ko);return new S({gridSize:[f,g],gridOrigin:d,gridOffset:[p.xOffset,p.yOffset],colorRange:y,elevationRange:a,colorDomain:s,elevationDomain:l,cellSize:o,coverage:i,material:r,elevationScale:e,extruded:t},this.getSubLayerProps({id:"gpu-grid-cell"}),{data:{attributes:{colors:x.aggregationBuffer,elevations:h.aggregationBuffer}},colorMaxMinBuffer:x.maxMinBuffer,elevationMaxMinBuffer:h.maxMinBuffer,numInstances:f*g})}finalizeState(e){let{color:t,elevation:o}=this.state.weights;[t,o].forEach(i=>{let{aggregationBuffer:r,maxMinBuffer:a}=i;a?.destroy(),r?.destroy()}),super.finalizeState(e)}updateAggregationState(e){let{props:t,oldProps:o}=e,{cellSize:i,coordinateSystem:r}=t,{viewport:a}=this.context,s=o.cellSize!==i,{dimensions:l}=this.state,c=this.isAttributeChanged(jo),g=c||this.isAttributeChanged(),{boundingBox:f}=this.state;if(c&&(f=Ie(this.getAttributes(),this.getNumInstances()),this.setState({boundingBox:f})),c||s){let{gridOffset:p,translation:x,width:h,height:y,numCol:S,numRow:A}=Re(f,i,a,r);this.allocateResources(A,S),this.setState({gridOffset:p,translation:x,gridOrigin:[-1*x[0],-1*x[1]],width:h,height:y,numCol:S,numRow:A})}let d=g||this.isAggregationDirty(e,{dimension:l.data,compareAll:!0});d&&this._updateAccessors(e),this.setState({aggregationDataDirty:d})}_updateAccessors(e){let{colorAggregation:t,elevationAggregation:o}=e.props,{color:i,elevation:r}=this.state.weights;i.operation=T[t],r.operation=T[o]}};Me.layerName="GPUGridLayer";Me.defaultProps=Sr;var Te=Me;var Ar={...Te.defaultProps,...Se.defaultProps,gpuAggregation:!1},Ce=class extends qo.CompositeLayer{initializeState(){this.state={useGPUAggregation:!1}}updateState({props:e}){this.setState({useGPUAggregation:!1})}renderLayers(){let{data:e,updateTriggers:t}=this.props,o=this.state.useGPUAggregation?"GPU":"CPU",i=this.state.useGPUAggregation?this.getSubLayerClass("GPU",Te):this.getSubLayerClass("CPU",Se);return new i(this.props,this.getSubLayerProps({id:o,updateTriggers:t}),{data:e})}canUseGPUAggregation(e){let{gpuAggregation:t,lowerPercentile:o,upperPercentile:i,getColorValue:r,getElevationValue:a,colorScaleType:s}=e;return!(!t||!C.isSupported(this.context.device)||o!==0||i!==100||r!==null||a!==null||s==="quantile"||s==="ordinal")}};Ce.layerName="GridLayer";Ce.defaultProps=Ar;var Yo=Ce;function Ko(n){let e=n.map(s=>s[0]),t=n.map(s=>s[1]),o=Math.min.apply(null,e),i=Math.max.apply(null,e),r=Math.min.apply(null,t),a=Math.max.apply(null,t);return[o,r,i,a]}function Qo(n,e){return e[0]>=n[0]&&e[2]<=n[2]&&e[1]>=n[1]&&e[3]<=n[3]}var $o=new Float32Array(12);function it(n,e=2){let t=0;for(let o of n)for(let i=0;i<e;i++)$o[t++]=o[i]||0;return $o}function Zo(n,e,t){let[o,i,r,a]=n,s=r-o,l=a-i,c=s,g=l;s/l<e/t?c=e/t*l:g=t/e*s,c<e&&(c=e,g=t);let f=(r+o)/2,d=(a+i)/2;return[f-c/2,d-g/2,f+c/2,d+g/2]}function Jo(n,e){let[t,o,i,r]=e;return[(n[0]-t)/(i-t),(n[1]-o)/(r-o)]}var st=M(k(),1),I=M(E(),1);var oi=M(k(),1),je=M(E(),1);var ei=`#version 300 es
#define SHADER_NAME heatp-map-layer-vertex-shader
uniform sampler2D maxTexture;
uniform float intensity;
uniform vec2 colorDomain;
uniform float threshold;
uniform float aggregationMode;
in vec3 positions;
in vec2 texCoords;
out vec2 vTexCoords;
out float vIntensityMin;
out float vIntensityMax;
void main(void) {
gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
vTexCoords = texCoords;
vec4 maxTexture = texture(maxTexture, vec2(0.5));
float maxValue = aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;
float minValue = maxValue * threshold;
if (colorDomain[1] > 0.) {
maxValue = colorDomain[1];
minValue = colorDomain[0];
}
vIntensityMax = intensity / maxValue;
vIntensityMin = intensity / minValue;
}
`;var ti=`#version 300 es
#define SHADER_NAME triangle-layer-fragment-shader
precision highp float;
uniform float opacity;
uniform sampler2D weightsTexture;
uniform sampler2D colorTexture;
uniform float aggregationMode;
in vec2 vTexCoords;
in float vIntensityMin;
in float vIntensityMax;
out vec4 fragColor;
vec4 getLinearColor(float value) {
float factor = clamp(value * vIntensityMax, 0., 1.);
vec4 color = texture(colorTexture, vec2(factor, 0.5));
color.a *= min(value * vIntensityMin, 1.0);
return color;
}
void main(void) {
vec4 weights = texture(weightsTexture, vTexCoords);
float weight = weights.r;
if (aggregationMode > 0.5) {
weight /= max(1.0, weights.a);
}
if (weight <= 0.) {
discard;
}
vec4 linearColor = getLinearColor(weight);
linearColor.a *= opacity;
fragColor = linearColor;
}
`;var ke=class extends je.Layer{getShaders(){return{vs:ei,fs:ti,modules:[je.project32]}}initializeState({device:e}){this.setState({model:this._getModel(e)})}_getModel(e){let{vertexCount:t,data:o,weightsTexture:i,maxTexture:r,colorTexture:a}=this.props;return new oi.Model(e,{...this.getShaders(),id:this.props.id,bindings:{weightsTexture:i,maxTexture:r,colorTexture:a},attributes:o.attributes,bufferLayout:[{name:"positions",format:"float32x3"},{name:"texCoords",format:"float32x2"}],topology:"triangle-fan-webgl",vertexCount:t})}draw({uniforms:e}){let{model:t}=this.state,{intensity:o,threshold:i,aggregationMode:r,colorDomain:a}=this.props;t.setUniforms({...e,intensity:o,threshold:i,aggregationMode:r,colorDomain:a}),t.draw(this.context.renderPass)}};ke.layerName="TriangleLayer";var ii=ke;var rt=`#version 300 es
in vec3 positions;
in vec3 positions64Low;
in float weights;
out vec4 weightsTexture;
uniform float radiusPixels;
uniform float textureWidth;
uniform vec4 commonBounds;
uniform float weightsScale;
void main()
{
weightsTexture = vec4(weights * weightsScale, 0., 0., 1.);
float radiusTexels = project_pixel_size(radiusPixels) * textureWidth / (commonBounds.z - commonBounds.x);
gl_PointSize = radiusTexels * 2.;
vec3 commonPosition = project_position(positions, positions64Low);
gl_Position.xy = (commonPosition.xy - commonBounds.xy) / (commonBounds.zw - commonBounds.xy) ;
gl_Position.xy = (gl_Position.xy * 2.) - (1.);
gl_Position.w = 1.0;
}
`;var nt=`#version 300 es
in vec4 weightsTexture;
out vec4 fragColor;
float gaussianKDE(float u){
return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
float dist = length(gl_PointCoord - vec2(0.5, 0.5));
if (dist > 0.5) {
discard;
}
fragColor = weightsTexture * gaussianKDE(2. * dist);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var ri=`#version 300 es
uniform sampler2D inTexture;
uniform float textureSize;
out vec4 outTexture;
void main()
{
int yIndex = gl_VertexID / int(textureSize);
int xIndex = gl_VertexID - (yIndex * int(textureSize));
vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / textureSize;
outTexture = texture(inTexture, uv);
gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
gl_PointSize = 1.0;
}
`;var ni=`#version 300 es
in vec4 outTexture;
out vec4 fragColor;
void main() {
fragColor = outTexture;
fragColor.g = outTexture.r / max(1.0, outTexture.a);
}
`;var _r=2,at={format:"rgba8unorm",mipmaps:!1,sampler:{minFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}},ai=[0,0],br={SUM:0,MEAN:1},Mr={getPosition:{type:"accessor",value:n=>n.position},getWeight:{type:"accessor",value:1},intensity:{type:"number",min:0,value:1},radiusPixels:{type:"number",min:1,max:100,value:50},colorRange:N,threshold:{type:"number",min:0,max:1,value:.05},colorDomain:{type:"array",value:null,optional:!0},aggregation:"SUM",weightsTextureSize:{type:"number",min:128,max:2048,value:2048},debounceTimeout:{type:"number",min:0,max:1e3,value:500}},Tr=["float32-renderable-webgl","texture-blend-float-webgl"],Cr={data:{props:["radiusPixels"]}},Ee=class extends O{initializeState(){super.initializeAggregationLayer(Cr),this.setState({colorDomain:ai}),this._setupTextureParams(),this._setupAttributes(),this._setupResources()}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState(e){super.updateState(e),this._updateHeatmapState(e)}_updateHeatmapState(e){let{props:t,oldProps:o}=e,i=this._getChangeFlags(e);(i.dataChanged||i.viewportChanged)&&(i.boundsChanged=this._updateBounds(i.dataChanged),this._updateTextureRenderingBounds()),i.dataChanged||i.boundsChanged?(clearTimeout(this.state.updateTimer),this.setState({isWeightMapDirty:!0})):i.viewportZoomChanged&&this._debouncedUpdateWeightmap(),t.colorRange!==o.colorRange&&this._updateColorTexture(e),this.state.isWeightMapDirty&&this._updateWeightmap(),this.setState({zoom:e.context.viewport.zoom})}renderLayers(){let{weightsTexture:e,triPositionBuffer:t,triTexCoordBuffer:o,maxWeightsTexture:i,colorTexture:r,colorDomain:a}=this.state,{updateTriggers:s,intensity:l,threshold:c,aggregation:g}=this.props,f=this.getSubLayerClass("triangle",ii);return new f(this.getSubLayerProps({id:"triangle-layer",updateTriggers:s}),{coordinateSystem:I.COORDINATE_SYSTEM.DEFAULT,data:{attributes:{positions:t,texCoords:o}},vertexCount:4,maxTexture:i,colorTexture:r,aggregationMode:br[g]||0,weightsTexture:e,intensity:l,threshold:c,colorDomain:a})}finalizeState(e){super.finalizeState(e);let{weightsTransform:t,weightsTexture:o,maxWeightTransform:i,maxWeightsTexture:r,triPositionBuffer:a,triTexCoordBuffer:s,colorTexture:l,updateTimer:c}=this.state;t?.destroy(),o?.destroy(),i?.destroy(),r?.destroy(),a?.destroy(),s?.destroy(),l?.destroy(),c&&clearTimeout(c)}_getAttributeManager(){return new I.AttributeManager(this.context.device,{id:this.props.id,stats:this.context.stats})}_getChangeFlags(e){let t={},{dimensions:o}=this.state;t.dataChanged=this.isAttributeChanged()&&"attribute changed"||this.isAggregationDirty(e,{compareAll:!0,dimension:o.data})&&"aggregation is dirty",t.viewportChanged=e.changeFlags.viewportChanged;let{zoom:i}=this.state;return(!e.context.viewport||e.context.viewport.zoom!==i)&&(t.viewportZoomChanged=!0),t}_createTextures(){let{textureSize:e,format:t}=this.state;this.setState({weightsTexture:this.context.device.createTexture({...at,width:e,height:e,format:t}),maxWeightsTexture:this.context.device.createTexture({...at,width:1,height:1,format:t})})}_setupAttributes(){this.getAttributeManager().add({positions:{size:3,type:"float64",accessor:"getPosition"},weights:{size:1,accessor:"getWeight"}}),this.setState({positionAttributeName:"positions"})}_setupTextureParams(){let{device:e}=this.context,{weightsTextureSize:t}=this.props,o=Math.min(t,e.limits.maxTextureDimension2D),i=Tr.every(s=>e.features.has(s)),r=i?"rgba32float":"rgba8unorm",a=i?1:1/255;this.setState({textureSize:o,format:r,weightsScale:a}),i||I.log.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)()}_createWeightsTransform(e){let{weightsTransform:t}=this.state,{weightsTexture:o}=this.state,i=this.getAttributeManager();t?.destroy(),t=new st.TextureTransform(this.context.device,{id:`${this.id}-weights-transform`,bufferLayout:i.getBufferLayouts(),vertexCount:1,targetTexture:o,parameters:{depthWriteEnabled:!1,blendColorOperation:"add",blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one"},topology:"point-list",...e}),this.setState({weightsTransform:t})}_setupResources(){this._createTextures();let{device:e}=this.context,{textureSize:t,weightsTexture:o,maxWeightsTexture:i}=this.state,r=this.getShaders({vs:rt,fs:nt});this._createWeightsTransform(r);let a=this.getShaders({vs:ri,fs:ni}),s=new st.TextureTransform(e,{id:`${this.id}-max-weights-transform`,bindings:{inTexture:o},uniforms:{textureSize:t},targetTexture:i,...a,vertexCount:t*t,topology:"point-list",parameters:{depthWriteEnabled:!1,blendColorOperation:"max",blendAlphaOperation:"max",blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one"}});this.setState({weightsTexture:o,maxWeightsTexture:i,maxWeightTransform:s,zoom:null,triPositionBuffer:e.createBuffer({byteLength:48}),triTexCoordBuffer:e.createBuffer({byteLength:48})})}updateShaders(e){this._createWeightsTransform({vs:rt,fs:nt,...e})}_updateMaxWeightValue(){let{maxWeightTransform:e}=this.state;e.run({parameters:{viewport:[0,0,1,1]},clearColor:[0,0,0,0]})}_updateBounds(e=!1){let{viewport:t}=this.context,o=[t.unproject([0,0]),t.unproject([t.width,0]),t.unproject([t.width,t.height]),t.unproject([0,t.height])].map(s=>s.map(Math.fround)),i=Ko(o),r={visibleWorldBounds:i,viewportCorners:o},a=!1;if(e||!this.state.worldBounds||!Qo(this.state.worldBounds,i)){let s=this._worldToCommonBounds(i),l=this._commonToWorldBounds(s);this.props.coordinateSystem===I.COORDINATE_SYSTEM.LNGLAT&&(l[1]=Math.max(l[1],-85.051129),l[3]=Math.min(l[3],85.051129),l[0]=Math.max(l[0],-360),l[2]=Math.min(l[2],360));let c=this._worldToCommonBounds(l);r.worldBounds=l,r.normalizedCommonBounds=c,a=!0}return this.setState(r),a}_updateTextureRenderingBounds(){let{triPositionBuffer:e,triTexCoordBuffer:t,normalizedCommonBounds:o,viewportCorners:i}=this.state,{viewport:r}=this.context;e.write(it(i,3));let a=i.map(s=>Jo(r.projectPosition(s),o));t.write(it(a,2))}_updateColorTexture(e){let{colorRange:t}=e.props,{colorTexture:o}=this.state,i=G(t,!1,Uint8Array);o&&o?.width===t.length?o.setSubImageData({data:i}):(o?.destroy(),o=this.context.device.createTexture({...at,data:i,width:t.length,height:1})),this.setState({colorTexture:o})}_updateWeightmap(){let{radiusPixels:e,colorDomain:t,aggregation:o}=this.props,{worldBounds:i,textureSize:r,weightsScale:a}=this.state,s=this.state.weightsTransform;this.state.isWeightMapDirty=!1;let l=this._worldToCommonBounds(i,{useLayerCoordinateSystem:!0});if(t&&o==="SUM"){let{viewport:p}=this.context,x=p.distanceScales.metersPerUnit[2]*(l[2]-l[0])/r;this.state.colorDomain=t.map(h=>h*x*a)}else this.state.colorDomain=t||ai;let g=this.getAttributeManager().getAttributes(),f=this.getModuleSettings(),d={radiusPixels:e,commonBounds:l,textureWidth:r,weightsScale:a};this._setModelAttributes(s.model,g),s.model.setVertexCount(this.getNumInstances()),s.model.setUniforms(d),s.model.updateModuleSettings(f),s.run({parameters:{viewport:[0,0,r,r]},clearColor:[0,0,0,0]}),this._updateMaxWeightValue()}_debouncedUpdateWeightmap(e=!1){let{updateTimer:t}=this.state,{debounceTimeout:o}=this.props;e?(t=null,this._updateBounds(!0),this._updateTextureRenderingBounds(),this.setState({isWeightMapDirty:!0})):(this.setState({isWeightMapDirty:!1}),clearTimeout(t),t=setTimeout(this._debouncedUpdateWeightmap.bind(this,!0),o)),this.setState({updateTimer:t})}_worldToCommonBounds(e,t={}){let{useLayerCoordinateSystem:o=!1}=t,[i,r,a,s]=e,{viewport:l}=this.context,{textureSize:c}=this.state,{coordinateSystem:g}=this.props,f=o&&(g===I.COORDINATE_SYSTEM.LNGLAT_OFFSETS||g===I.COORDINATE_SYSTEM.METER_OFFSETS),d=f?l.projectPosition(this.props.coordinateOrigin):[0,0],p=c*_r/l.scale,x,h;return o&&!f?(x=this.projectPosition([i,r,0]),h=this.projectPosition([a,s,0])):(x=l.projectPosition([i,r,0]),h=l.projectPosition([a,s,0])),Zo([x[0]-d[0],x[1]-d[1],h[0]-d[0],h[1]-d[1]],p,p)}_commonToWorldBounds(e){let[t,o,i,r]=e,{viewport:a}=this.context,s=a.unprojectPosition([t,o]),l=a.unprojectPosition([i,r]);return s.slice(0,2).concat(l.slice(0,2))}};Ee.layerName="HeatmapLayer";Ee.defaultProps=Mr;var si=Ee;return pi(Pe);})();
      return __exports__;
      });
